<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ôî ELOISE ¬∑ Online Schach</title>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', sans-serif;
            background: #0a0c10;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        .game-wrapper {
            max-width: 1400px;
            width: 100%;
            background: #14181c;
            border-radius: 24px;
            padding: 24px;
        }
        .server-bar {
            display: flex;
            justify-content: space-between;
            background: #1e232a;
            padding: 12px 20px;
            border-radius: 100px;
            margin-bottom: 24px;
        }
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .online { background: #2ecc71; box-shadow: 0 0 10px #2ecc71; }
        .offline { background: #e74c3c; box-shadow: 0 0 10px #e74c3c; }
        .connecting { background: #f39c12; box-shadow: 0 0 10px #f39c12; }
        
        .lobby-layout {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 24px;
        }
        .lobby-sidebar {
            background: #1e232a;
            border-radius: 20px;
            padding: 20px;
        }
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 12px;
            background: #2f3542;
            color: white;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .btn-primary { background: linear-gradient(135deg, #667eea, #764ba2); }
        .btn-danger { background: #e74c3c; }
        
        .lobby-item {
            background: #232931;
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .join-btn {
            background: #2ecc71;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
        }
        
        .board-container {
            max-width: 560px;
            margin: 0 auto;
            aspect-ratio: 1;
        }
        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            width: 100%;
            height: 100%;
            border: 2px solid #3a4050;
            border-radius: 8px;
            overflow: hidden;
        }
        .square {
            aspect-ratio: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.2em;
            cursor: pointer;
            position: relative;
        }
        .square.light { background: #eadbc5; }
        .square.dark { background: #b08b5c; }
        .square.selected { background: #6b9ac4 !important; }
        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 25px;
            height: 25px;
            background: rgba(46, 204, 113, 0.7);
            border-radius: 50%;
        }
        .square.check { background: #e74c3c !important; }
        
        .player-card {
            flex: 1;
            background: #232931;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid transparent;
        }
        .player-card.active {
            border: 2px solid #667eea;
            background: linear-gradient(145deg, #2a3140, #1e232c);
        }
        
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #1e232a;
            border-left: 4px solid #667eea;
            padding: 16px 24px;
            border-radius: 12px;
            color: white;
            transform: translateX(400px);
            transition: transform 0.3s;
            z-index: 9999;
        }
        .toast.show { transform: translateX(0); }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <!-- Server Status -->
        <div class="server-bar">
            <div>
                <span class="status-dot online" id="statusDot"></span>
                <span id="statusText">Verbinde...</span>
            </div>
            <div>üì∂ <span id="pingValue">0</span> ms</div>
            <div>üë• <span id="onlineCount">0</span> online</div>
            <div>üéÆ <span id="roomCount">0</span> R√§ume</div>
        </div>

        <!-- Main Layout -->
        <div class="lobby-layout">
            <!-- Lobby -->
            <div class="lobby-sidebar">
                <h2 style="color: white; margin-bottom: 20px;">üéÆ Lobby</h2>
                
                <div style="background: #2a3038; padding: 12px; border-radius: 100px; margin-bottom: 20px;">
                    üë§ <span id="playerNameDisplay" style="color: white;">Name eingeben</span>
                </div>
                
                <input type="text" id="playerNameInput" placeholder="Dein Name" 
                       style="width: 100%; padding: 12px; background: #2a3038; border: none; border-radius: 12px; color: white; margin-bottom: 10px;">
                <button id="saveNameBtn" class="btn btn-primary">Name speichern</button>
                <button id="createRoomBtn" class="btn btn-primary" style="margin-top: 10px;">üåç √ñffentliches Spiel erstellen</button>
                
                <div style="margin-top: 30px;">
                    <h3 style="color: white; margin-bottom: 15px;">üü¢ Verf√ºgbare Spiele</h3>
                    <div id="lobbyList" style="max-height: 400px; overflow-y: auto;"></div>
                </div>
                
                <div id="currentRoomCard" style="display: none; margin-top: 20px; background: #232931; padding: 15px; border-radius: 12px;">
                    <h4 style="color: white; margin-bottom: 10px;">Aktueller Raum</h4>
                    <div id="roomDetails" style="color: #a0b3ff; margin-bottom: 10px;"></div>
                    <button id="leaveRoomBtn" class="btn btn-danger">Raum verlassen</button>
                </div>
            </div>
            
            <!-- Game Area -->
            <div style="background: #1e232a; border-radius: 20px; padding: 20px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 20px;">
                    <div style="background: rgba(102,126,234,0.15); padding: 8px 16px; border-radius: 100px;">
                        üéØ <span id="roomIdDisplay">Kein Raum</span>
                    </div>
                    <button id="resetGameBtn" class="btn" style="width: auto; padding: 8px 20px;">üîÑ Neustart</button>
                </div>
                
                <div class="board-container">
                    <div id="chessboard"></div>
                </div>
                
                <div style="display: flex; gap: 20px; margin-top: 20px;">
                    <div class="player-card" id="whiteCard">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="font-size: 2em;">‚ôî</div>
                            <div>
                                <div style="color: white; font-weight: 600;" id="whiteName">Wei√ü</div>
                                <div style="color: #8e9aaf;" id="whiteStatus">Wartet...</div>
                            </div>
                        </div>
                    </div>
                    <div class="player-card" id="blackCard">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="font-size: 2em;">‚ôö</div>
                            <div>
                                <div style="color: white; font-weight: 600;" id="blackName">Schwarz</div>
                                <div style="color: #8e9aaf;" id="blackStatus">Wartet...</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 20px; background: #232931; padding: 15px; border-radius: 12px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span style="color: white;">üìú Zugverlauf</span>
                        <span style="color: #8e9aaf;" id="moveCount">0 Z√ºge</span>
                    </div>
                    <div id="movesList" style="display: grid; grid-template-columns: repeat(2,1fr); gap: 5px; max-height: 150px; overflow-y: auto;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>

    <script>
        // =========================================
        // FIREBASE KONFIGURATION
        // =========================================
        const firebaseConfig = {
            apiKey: "AIzaSyBg8mOUWGRWCdfiF5RrLoRWQz0DYQE2W2Q",
            authDomain: "schach-a98cc.firebaseapp.com",
            databaseURL: "https://schach-a98cc-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "schach-a98cc",
            storageBucket: "schach-a98cc.firebasestorage.app",
            messagingSenderId: "374332466146",
            appId: "1:374332466146:web:6ff16f969d464136838fbb"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        // =========================================
        // VOLLST√ÑNDIGE SCHACH ENGINE
        // =========================================
        class ChessEngine {
            constructor() {
                this.reset();
            }

            reset() {
                this.board = [
                    ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
                    ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
                    ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
                ];
                this.currentPlayer = 'w';
                this.selectedPiece = null;
                this.validMoves = [];
                this.gameOver = false;
                this.moveHistory = [];
                this.capturedPieces = { w: [], b: [] };
                this.enPassantTarget = null;
                this.castlingRights = {
                    w: { kingMoved: false, rookLeftMoved: false, rookRightMoved: false },
                    b: { kingMoved: false, rookLeftMoved: false, rookRightMoved: false }
                };
            }

            getPieceColor(piece) {
                if (!piece) return null;
                return piece === piece.toLowerCase() ? 'b' : 'w';
            }

            getPieceType(piece) {
                if (!piece) return null;
                const types = {
                    '‚ôî': 'K', '‚ôï': 'Q', '‚ôñ': 'R', '‚ôó': 'B', '‚ôò': 'N', '‚ôô': 'P',
                    '‚ôö': 'K', '‚ôõ': 'Q', '‚ôú': 'R', '‚ôù': 'B', '‚ôû': 'N', '‚ôü': 'P'
                };
                return types[piece];
            }

            isInBounds(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            getValidMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];
                
                const color = this.getPieceColor(piece);
                const type = this.getPieceType(piece);
                let moves = [];

                switch (type) {
                    case 'P': moves = this.getPawnMoves(row, col, color); break;
                    case 'R': moves = this.getRookMoves(row, col, color); break;
                    case 'N': moves = this.getKnightMoves(row, col, color); break;
                    case 'B': moves = this.getBishopMoves(row, col, color); break;
                    case 'Q': moves = this.getQueenMoves(row, col, color); break;
                    case 'K': moves = this.getKingMoves(row, col, color); break;
                }

                return moves.filter(move => {
                    const newBoard = this.simulateMove(row, col, move.row, move.col);
                    return !this.isInCheck(color, newBoard);
                });
            }

            getPawnMoves(row, col, color) {
                const moves = [];
                const direction = color === 'w' ? -1 : 1;
                const startRow = color === 'w' ? 6 : 1;

                if (this.isInBounds(row + direction, col) && !this.board[row + direction][col]) {
                    moves.push({ row: row + direction, col });
                    if (row === startRow && !this.board[row + 2 * direction][col]) {
                        moves.push({ row: row + 2 * direction, col });
                    }
                }

                for (const dCol of [-1, 1]) {
                    const newRow = row + direction;
                    const newCol = col + dCol;
                    if (this.isInBounds(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (targetPiece && this.getPieceColor(targetPiece) !== color) {
                            moves.push({ row: newRow, col: newCol, capture: true });
                        }
                        if (this.enPassantTarget && 
                            this.enPassantTarget.row === newRow && 
                            this.enPassantTarget.col === newCol) {
                            moves.push({ row: newRow, col: newCol, enPassant: true });
                        }
                    }
                }
                return moves;
            }

            getRookMoves(row, col, color) {
                const moves = [];
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                for (const [dRow, dCol] of directions) {
                    let newRow = row + dRow;
                    let newCol = col + dCol;
                    while (this.isInBounds(newRow, newCol)) {
                        if (!this.board[newRow][newCol]) {
                            moves.push({ row: newRow, col: newCol });
                        } else {
                            if (this.getPieceColor(this.board[newRow][newCol]) !== color) {
                                moves.push({ row: newRow, col: newCol, capture: true });
                            }
                            break;
                        }
                        newRow += dRow;
                        newCol += dCol;
                    }
                }
                return moves;
            }

            getKnightMoves(row, col, color) {
                const moves = [];
                const offsets = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
                for (const [dRow, dCol] of offsets) {
                    const newRow = row + dRow;
                    const newCol = col + dCol;
                    if (this.isInBounds(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece) {
                            moves.push({ row: newRow, col: newCol });
                        } else if (this.getPieceColor(targetPiece) !== color) {
                            moves.push({ row: newRow, col: newCol, capture: true });
                        }
                    }
                }
                return moves;
            }

            getBishopMoves(row, col, color) {
                const moves = [];
                const directions = [[-1,-1], [-1,1], [1,-1], [1,1]];
                for (const [dRow, dCol] of directions) {
                    let newRow = row + dRow;
                    let newCol = col + dCol;
                    while (this.isInBounds(newRow, newCol)) {
                        if (!this.board[newRow][newCol]) {
                            moves.push({ row: newRow, col: newCol });
                        } else {
                            if (this.getPieceColor(this.board[newRow][newCol]) !== color) {
                                moves.push({ row: newRow, col: newCol, capture: true });
                            }
                            break;
                        }
                        newRow += dRow;
                        newCol += dCol;
                    }
                }
                return moves;
            }

            getQueenMoves(row, col, color) {
                return [...this.getRookMoves(row, col, color), ...this.getBishopMoves(row, col, color)];
            }

            getKingMoves(row, col, color) {
                const moves = [];
                for (let dRow = -1; dRow <= 1; dRow++) {
                    for (let dCol = -1; dCol <= 1; dCol++) {
                        if (dRow === 0 && dCol === 0) continue;
                        const newRow = row + dRow;
                        const newCol = col + dCol;
                        if (this.isInBounds(newRow, newCol)) {
                            const targetPiece = this.board[newRow][newCol];
                            if (!targetPiece) {
                                moves.push({ row: newRow, col: newCol });
                            } else if (this.getPieceColor(targetPiece) !== color) {
                                moves.push({ row: newRow, col: newCol, capture: true });
                            }
                        }
                    }
                }
                
                // Castling
                if (!this.castlingRights[color].kingMoved) {
                    if (!this.castlingRights[color].rookRightMoved &&
                        !this.board[row][col+1] && !this.board[row][col+2] &&
                        !this.isSquareAttacked(row, col, color) &&
                        !this.isSquareAttacked(row, col+1, color) &&
                        !this.isSquareAttacked(row, col+2, color)) {
                        moves.push({ row, col: col+2, castling: 'short' });
                    }
                    if (!this.castlingRights[color].rookLeftMoved &&
                        !this.board[row][col-1] && !this.board[row][col-2] && !this.board[row][col-3] &&
                        !this.isSquareAttacked(row, col, color) &&
                        !this.isSquareAttacked(row, col-1, color) &&
                        !this.isSquareAttacked(row, col-2, color)) {
                        moves.push({ row, col: col-2, castling: 'long' });
                    }
                }
                return moves;
            }

            isSquareAttacked(row, col, defendingColor) {
                const attackingColor = defendingColor === 'w' ? 'b' : 'w';
                
                // Pawns
                const pawnDirection = defendingColor === 'w' ? 1 : -1;
                for (const dCol of [-1, 1]) {
                    const newRow = row + pawnDirection;
                    const newCol = col + dCol;
                    if (this.isInBounds(newRow, newCol)) {
                        const piece = this.board[newRow][newCol];
                        if (piece && this.getPieceColor(piece) === attackingColor && 
                            (piece === '‚ôô' || piece === '‚ôü')) {
                            return true;
                        }
                    }
                }
                
                // Knights
                const knightMoves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
                for (const [dRow, dCol] of knightMoves) {
                    const newRow = row + dRow;
                    const newCol = col + dCol;
                    if (this.isInBounds(newRow, newCol)) {
                        const piece = this.board[newRow][newCol];
                        if (piece && this.getPieceColor(piece) === attackingColor &&
                            (piece === '‚ôò' || piece === '‚ôû')) {
                            return true;
                        }
                    }
                }
                
                // Rooks/Queens
                const rookDirections = [[-1,0], [1,0], [0,-1], [0,1]];
                for (const [dRow, dCol] of rookDirections) {
                    let newRow = row + dRow;
                    let newCol = col + dCol;
                    while (this.isInBounds(newRow, newCol)) {
                        const piece = this.board[newRow][newCol];
                        if (piece) {
                            if (this.getPieceColor(piece) === attackingColor &&
                                (piece === '‚ôñ' || piece === '‚ôú' || piece === '‚ôï' || piece === '‚ôõ')) {
                                return true;
                            }
                            break;
                        }
                        newRow += dRow;
                        newCol += dCol;
                    }
                }
                
                // Bishops/Queens
                const bishopDirections = [[-1,-1], [-1,1], [1,-1], [1,1]];
                for (const [dRow, dCol] of bishopDirections) {
                    let newRow = row + dRow;
                    let newCol = col + dCol;
                    while (this.isInBounds(newRow, newCol)) {
                        const piece = this.board[newRow][newCol];
                        if (piece) {
                            if (this.getPieceColor(piece) === attackingColor &&
                                (piece === '‚ôó' || piece === '‚ôù' || piece === '‚ôï' || piece === '‚ôõ')) {
                                return true;
                            }
                            break;
                        }
                        newRow += dRow;
                        newCol += dCol;
                    }
                }
                
                // King
                for (let dRow = -1; dRow <= 1; dRow++) {
                    for (let dCol = -1; dCol <= 1; dCol++) {
                        if (dRow === 0 && dCol === 0) continue;
                        const newRow = row + dRow;
                        const newCol = col + dCol;
                        if (this.isInBounds(newRow, newCol)) {
                            const piece = this.board[newRow][newCol];
                            if (piece && this.getPieceColor(piece) === attackingColor &&
                                (piece === '‚ôî' || piece === '‚ôö')) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            simulateMove(fromRow, fromCol, toRow, toCol) {
                const newBoard = this.board.map(row => [...row]);
                newBoard[toRow][toCol] = newBoard[fromRow][fromCol];
                newBoard[fromRow][fromCol] = '';
                return newBoard;
            }

            isInCheck(color, board = this.board) {
                const kingSymbol = color === 'w' ? '‚ôî' : '‚ôö';
                let kingRow = -1, kingCol = -1;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (board[row][col] === kingSymbol) {
                            kingRow = row;
                            kingCol = col;
                            break;
                        }
                    }
                    if (kingRow !== -1) break;
                }
                if (kingRow === -1) return false;
                
                const tempBoard = this.board;
                this.board = board;
                const attacked = this.isSquareAttacked(kingRow, kingCol, color);
                this.board = tempBoard;
                return attacked;
            }

            isCheckmate(color) {
                if (!this.isInCheck(color)) return false;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && this.getPieceColor(piece) === color) {
                            if (this.getValidMoves(row, col).length > 0) return false;
                        }
                    }
                }
                return true;
            }

            isStalemate(color) {
                if (this.isInCheck(color)) return false;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = this.board[row][col];
                        if (piece && this.getPieceColor(piece) === color) {
                            if (this.getValidMoves(row, col).length > 0) return false;
                        }
                    }
                }
                return true;
            }

            makeMove(fromRow, fromCol, toRow, toCol) {
                // Pr√ºfe ob Figur existiert
                const piece = this.board[fromRow][fromCol];
                if (!piece) {
                    return { success: false, error: 'Keine Figur ausgew√§hlt' };
                }
                
                // Pr√ºfe ob Figur dem aktuellen Spieler geh√∂rt
                if (this.getPieceColor(piece) !== this.currentPlayer) {
                    return { success: false, error: 'Nicht deine Figur' };
                }
                
                // Validiere Zug
                const moves = this.getValidMoves(fromRow, fromCol);
                const move = moves.find(m => m.row === toRow && m.col === toCol);
                
                if (!move) {
                    return { success: false, error: 'Ung√ºltiger Zug' };
                }
                
                const pieceColor = this.getPieceColor(piece);
                const pieceType = this.getPieceType(piece);
                const targetPiece = this.board[toRow][toCol];
                
                // Geschlagene Figur speichern
                if (targetPiece) {
                    this.capturedPieces[pieceColor === 'w' ? 'b' : 'w'].push(targetPiece);
                }
                
                // En Passant
                if (move.enPassant) {
                    const capturedPawn = this.board[fromRow][toCol];
                    this.capturedPieces[pieceColor === 'w' ? 'b' : 'w'].push(capturedPawn);
                    this.board[fromRow][toCol] = '';
                }
                
                // Rochade
                if (move.castling) {
                    if (move.castling === 'short') {
                        this.board[toRow][toCol-1] = this.board[toRow][toCol+1];
                        this.board[toRow][toCol+1] = '';
                    } else if (move.castling === 'long') {
                        this.board[toRow][toCol+1] = this.board[toRow][toCol-2];
                        this.board[toRow][toCol-2] = '';
                    }
                }
                
                // Figur bewegen
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = '';
                
                // Bauernumwandlung
                if (pieceType === 'P' && (toRow === 0 || toRow === 7)) {
                    this.board[toRow][toCol] = pieceColor === 'w' ? '‚ôï' : '‚ôõ';
                }
                
                // En Passant Ziel setzen
                this.enPassantTarget = null;
                if (pieceType === 'P' && Math.abs(fromRow - toRow) === 2) {
                    this.enPassantTarget = {
                        row: (fromRow + toRow) / 2,
                        col: fromCol
                    };
                }
                
                // Rochaderechte aktualisieren
                if (pieceType === 'K') {
                    this.castlingRights[pieceColor].kingMoved = true;
                }
                if (pieceType === 'R') {
                    if (fromCol === 0) this.castlingRights[pieceColor].rookLeftMoved = true;
                    if (fromCol === 7) this.castlingRights[pieceColor].rookRightMoved = true;
                }
                
                // Zugnotation
                const cols = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                const rows = ['8', '7', '6', '5', '4', '3', '2', '1'];
                let notation = '';
                
                if (move.castling) {
                    notation = move.castling === 'short' ? 'O-O' : 'O-O-O';
                } else {
                    if (pieceType === 'P') {
                        if (targetPiece || move.enPassant) notation += cols[fromCol];
                    } else {
                        notation += pieceType;
                    }
                    if (targetPiece || move.enPassant) notation += 'x';
                    notation += cols[toCol] + rows[toRow];
                    if (move.enPassant) notation += ' e.p.';
                }
                
                this.moveHistory.push(notation);
                
                // Spieler wechseln
                this.currentPlayer = this.currentPlayer === 'w' ? 'b' : 'w';
                
                // Pr√ºfe Spielende
                if (this.isCheckmate(this.currentPlayer)) {
                    this.gameOver = true;
                    const winner = this.currentPlayer === 'w' ? 'Schwarz' : 'Wei√ü';
                    return { success: true, gameOver: true, result: `${winner} gewinnt durch Schachmatt!` };
                } else if (this.isStalemate(this.currentPlayer)) {
                    this.gameOver = true;
                    return { success: true, gameOver: true, result: 'Patt! Unentschieden.' };
                }
                
                return { success: true, gameOver: false };
            }

            getState() {
                return {
                    board: this.board,
                    currentPlayer: this.currentPlayer,
                    gameOver: this.gameOver,
                    moveHistory: this.moveHistory,
                    capturedPieces: this.capturedPieces,
                    enPassantTarget: this.enPassantTarget,
                    castlingRights: this.castlingRights
                };
            }

            loadState(state) {
                if (!state) return;
                this.board = state.board || this.board;
                this.currentPlayer = state.currentPlayer || 'w';
                this.gameOver = state.gameOver || false;
                this.moveHistory = state.moveHistory || [];
                this.capturedPieces = state.capturedPieces || { w: [], b: [] };
                this.enPassantTarget = state.enPassantTarget || null;
                this.castlingRights = state.castlingRights || {
                    w: { kingMoved: false, rookLeftMoved: false, rookRightMoved: false },
                    b: { kingMoved: false, rookLeftMoved: false, rookRightMoved: false }
                };
                this.selectedPiece = null;
                this.validMoves = [];
            }
        }

        // =========================================
        // GAME CONTROLLER
        // =========================================
        class GameController {
            constructor() {
                this.game = new ChessEngine();
                this.playerName = localStorage.getItem('chess_name') || '';
                this.playerId = 'p_' + Math.random().toString(36).substring(2, 10);
                this.currentRoom = null;
                this.playerColor = null;
                this.roomRef = null;
                this.isLocalMove = false;
                
                this.initUI();
                this.initFirebase();
                this.renderBoard();
                
                window.controller = this;
            }

            initUI() {
                document.getElementById('playerNameDisplay').innerText = this.playerName || 'Kein Name';
                document.getElementById('playerNameInput').value = this.playerName;
                
                document.getElementById('saveNameBtn').onclick = () => {
                    const name = document.getElementById('playerNameInput').value.trim();
                    if (name) {
                        this.playerName = name;
                        localStorage.setItem('chess_name', name);
                        document.getElementById('playerNameDisplay').innerText = name;
                        this.toast('‚úÖ Name gespeichert');
                    }
                };
                
                document.getElementById('createRoomBtn').onclick = () => this.createRoom();
                document.getElementById('leaveRoomBtn').onclick = () => this.leaveRoom();
                document.getElementById('resetGameBtn').onclick = () => this.resetGame();
                
                setInterval(() => {
                    const start = Date.now();
                    db.ref('.info/serverTimeOffset').once('value').then(() => {
                        const ping = Date.now() - start;
                        document.getElementById('pingValue').innerText = ping;
                    });
                }, 1000);
            }

            initFirebase() {
                const connected = db.ref('.info/connected');
                connected.on('value', (snap) => {
                    if (snap.val()) {
                        document.getElementById('statusDot').className = 'status-dot online';
                        document.getElementById('statusText').innerText = 'Verbunden';
                        this.initPresence();
                    } else {
                        document.getElementById('statusDot').className = 'status-dot offline';
                        document.getElementById('statusText').innerText = 'Offline';
                    }
                });
                
                db.ref('presence').on('value', (snap) => {
                    let online = 0;
                    if (snap.val()) {
                        Object.values(snap.val()).forEach(p => {
                            if (p.online && Date.now() - p.lastSeen < 120000) online++;
                        });
                    }
                    document.getElementById('onlineCount').innerText = online;
                });
                
                db.ref('rooms').on('value', (snap) => {
                    if (snap.val()) {
                        document.getElementById('roomCount').innerText = Object.keys(snap.val()).length;
                    }
                    this.updateLobby(snap.val());
                });
            }

            initPresence() {
                const presence = db.ref('presence/' + this.playerId);
                presence.set({
                    name: this.playerName,
                    online: true,
                    lastSeen: Date.now(),
                    currentRoom: this.currentRoom
                });
                presence.onDisconnect().update({
                    online: false,
                    lastSeen: Date.now()
                });
            }

            updateLobby(rooms) {
                const list = document.getElementById('lobbyList');
                if (!rooms) {
                    list.innerHTML = '<div style="color: #8e9aaf; text-align: center; padding: 20px;">Keine offenen Spiele</div>';
                    return;
                }
                
                let html = '';
                Object.entries(rooms).forEach(([id, room]) => {
                    if (room.isPublic === true && 
                        room.players && 
                        room.players.w && 
                        (!room.players.b || room.players.b === null) &&
                        room.creatorId !== this.playerId &&
                        id !== this.currentRoom) {
                        
                        const timeAgo = Math.floor((Date.now() - (room.created || Date.now())) / 60000);
                        html += `
                            <div class="lobby-item">
                                <div>
                                    <div style="color: #a0b3ff; font-size: 0.9em;">üë§ ${room.creatorName || 'Spieler'}</div>
                                    <div style="color: white;">${room.name || 'Schachspiel'}</div>
                                    <div style="color: #8e9aaf; font-size: 0.8em;">‚ö° vor ${timeAgo} min</div>
                                </div>
                                <button class="join-btn" onclick="controller.joinRoom('${id}')">Beitreten</button>
                            </div>
                        `;
                    }
                });
                
                list.innerHTML = html || '<div style="color: #8e9aaf; text-align: center; padding: 20px;">Keine offenen Spiele</div>';
            }

            async createRoom() {
                if (!this.playerName) {
                    this.toast('‚ùå Bitte erst Namen eingeben!');
                    return;
                }
                
                const roomId = 'game-' + Math.random().toString(36).substring(2, 8);
                this.currentRoom = roomId;
                this.playerColor = 'w';
                this.roomRef = db.ref('rooms/' + roomId);
                
                const roomData = {
                    isPublic: true,
                    name: `Spiel von ${this.playerName}`,
                    creatorId: this.playerId,
                    creatorName: this.playerName,
                    players: {
                        w: {
                            id: this.playerId,
                            name: this.playerName,
                            connected: true
                        },
                        b: null
                    },
                    ...this.game.getState(),
                    created: Date.now(),
                    lastUpdate: Date.now()
                };
                
                await this.roomRef.set(roomData);
                db.ref('presence/' + this.playerId).update({ currentRoom: roomId });
                
                document.getElementById('roomIdDisplay').innerText = roomId;
                document.getElementById('currentRoomCard').style.display = 'block';
                document.getElementById('roomDetails').innerHTML = `
                    üåç √ñffentliches Spiel<br>
                    ID: ${roomId}<br>
                    Du: Wei√ü (${this.playerName})
                `;
                
                document.getElementById('whiteName').innerHTML = `Wei√ü <span style="color: #2ecc71;">‚óè ${this.playerName}</span>`;
                document.getElementById('whiteStatus').innerText = 'Aktiv';
                document.getElementById('blackName').innerText = 'Schwarz';
                document.getElementById('blackStatus').innerText = 'Wartet...';
                
                this.setupRoomListener();
                this.renderBoard();
                this.toast('üåç Spiel erstellt! Warte auf Gegner...');
            }

            async joinRoom(roomId) {
                if (!this.playerName) {
                    this.toast('‚ùå Bitte erst Namen eingeben!');
                    return;
                }
                
                const roomRef = db.ref('rooms/' + roomId);
                const snap = await roomRef.get();
                if (!snap.exists()) {
                    this.toast('‚ùå Raum nicht gefunden!');
                    return;
                }
                
                const room = snap.val();
                if (room.players && room.players.b && room.players.b !== null) {
                    this.toast('‚ùå Dieser Raum ist bereits voll!');
                    return;
                }
                
                this.currentRoom = roomId;
                this.playerColor = 'b';
                this.roomRef = roomRef;
                
                this.game.loadState(room);
                
                await roomRef.update({
                    'players/b': {
                        id: this.playerId,
                        name: this.playerName,
                        connected: true
                    },
                    lastUpdate: Date.now()
                });
                
                db.ref('presence/' + this.playerId).update({ currentRoom: roomId });
                
                document.getElementById('roomIdDisplay').innerText = roomId;
                document.getElementById('currentRoomCard').style.display = 'block';
                document.getElementById('roomDetails').innerHTML = `
                    üåç √ñffentliches Spiel<br>
                    ID: ${roomId}<br>
                    Du: Schwarz (${this.playerName})<br>
                    Gegner: ${room.creatorName || 'Wei√ü'}
                `;
                
                document.getElementById('whiteName').innerHTML = `Wei√ü <span style="color: #2ecc71;">‚óè ${room.creatorName || 'Spieler'}</span>`;
                document.getElementById('whiteStatus').innerText = 'Aktiv';
                document.getElementById('blackName').innerHTML = `Schwarz <span style="color: #2ecc71;">‚óè ${this.playerName}</span>`;
                document.getElementById('blackStatus').innerText = 'Aktiv';
                
                this.setupRoomListener();
                this.renderBoard();
                this.toast('‚úÖ Raum beigetreten!');
            }

            setupRoomListener() {
                if (!this.roomRef) return;
                
                this.roomRef.on('value', (snap) => {
                    if (!snap.exists()) {
                        this.toast('üèÅ Raum wurde geschlossen');
                        this.leaveRoom(true);
                        return;
                    }
                    
                    const data = snap.val();
                    
                    if (!this.isLocalMove) {
                        this.game.loadState(data);
                        this.renderBoard();
                    }
                    this.isLocalMove = false;
                    
                    if (data.players) {
                        if (data.players.w) {
                            document.getElementById('whiteName').innerHTML = 
                                `Wei√ü <span style="color: #2ecc71;">‚óè ${data.players.w.name || 'Spieler'}</span>`;
                        }
                        if (data.players.b) {
                            document.getElementById('blackName').innerHTML = 
                                `Schwarz <span style="color: #2ecc71;">‚óè ${data.players.b.name || 'Spieler'}</span>`;
                            document.getElementById('blackStatus').innerText = 'Aktiv';
                        } else {
                            document.getElementById('blackName').innerText = 'Schwarz';
                            document.getElementById('blackStatus').innerText = 'Wartet...';
                        }
                    }
                });
            }

            async leaveRoom(silent = false) {
                if (this.roomRef) {
                    if (this.playerColor === 'w') {
                        await this.roomRef.remove();
                    } else {
                        await this.roomRef.update({
                            'players/b': null,
                            lastUpdate: Date.now()
                        });
                    }
                    this.roomRef.off();
                }
                
                db.ref('presence/' + this.playerId).update({ currentRoom: null });
                
                this.currentRoom = null;
                this.playerColor = null;
                this.roomRef = null;
                this.game.reset();
                
                document.getElementById('roomIdDisplay').innerText = 'Kein Raum';
                document.getElementById('currentRoomCard').style.display = 'none';
                document.getElementById('whiteName').innerHTML = 'Wei√ü';
                document.getElementById('whiteStatus').innerText = 'Wartet...';
                document.getElementById('blackName').innerHTML = 'Schwarz';
                document.getElementById('blackStatus').innerText = 'Wartet...';
                
                this.renderBoard();
                if (!silent) this.toast('üëã Raum verlassen');
            }

            async resetGame() {
                if (!this.currentRoom) {
                    this.toast('‚ùå Kein Raum verbunden!');
                    return;
                }
                if (this.playerColor !== 'w') {
                    this.toast('‚ùå Nur Wei√ü kann neustarten!');
                    return;
                }
                
                this.game.reset();
                this.isLocalMove = true;
                
                await this.roomRef.update({
                    ...this.game.getState(),
                    lastUpdate: Date.now()
                });
                
                this.toast('‚ú® Neues Spiel gestartet!');
            }

            renderBoard() {
                const board = document.getElementById('chessboard');
                board.innerHTML = '';
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const square = document.createElement('div');
                        square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                        
                        const piece = this.game.board[r][c];
                        if (piece) square.textContent = piece;
                        
                        if (this.game.selectedPiece && 
                            this.game.selectedPiece.row === r && 
                            this.game.selectedPiece.col === c) {
                            square.classList.add('selected');
                        }
                        
                        if (this.game.validMoves.some(m => m.row === r && m.col === c)) {
                            square.classList.add('possible-move');
                        }
                        
                        if (this.game.isInCheck(this.game.currentPlayer === 'w' ? 'b' : 'w')) {
                            const kingSymbol = this.game.currentPlayer === 'w' ? '‚ôö' : '‚ôî';
                            if (piece === kingSymbol) {
                                square.classList.add('check');
                            }
                        }
                        
                        square.onclick = () => this.handleSquareClick(r, c);
                        board.appendChild(square);
                    }
                }
                
                document.getElementById('moveCount').innerText = `${this.game.moveHistory.length} Z√ºge`;
                
                const movesList = document.getElementById('movesList');
                movesList.innerHTML = '';
                this.game.moveHistory.forEach((move, i) => {
                    const div = document.createElement('div');
                    div.style.cssText = 'background: #1a1e24; padding: 5px 10px; border-radius: 5px; color: #e1e9f0;';
                    if (i % 2 === 0) {
                        div.innerHTML = `<strong>${Math.floor(i / 2) + 1}.</strong> ${move}`;
                    } else {
                        div.innerText = move;
                    }
                    movesList.appendChild(div);
                });
                
                document.getElementById('whiteCard').classList.toggle('active', this.game.currentPlayer === 'w');
                document.getElementById('blackCard').classList.toggle('active', this.game.currentPlayer === 'b');
            }

            handleSquareClick(row, col) {
                // Pr√ºfe ob Raum verbunden
                if (!this.currentRoom) {
                    this.toast('üéÆ Erst Raum erstellen/beitreten!');
                    return;
                }
                
                // Pr√ºfe ob Spiel vorbei
                if (this.game.gameOver) {
                    this.toast('üèÅ Spiel beendet!');
                    return;
                }
                
                // Asynchrone Pr√ºfung des Gegners
                this.roomRef.once('value').then(async (snap) => {
                    const data = snap.val();
                    
                    // Pr√ºfe ob Gegner da ist
                    if (!data.players || !data.players.b) {
                        this.toast('‚è≥ Warte auf Gegner...');
                        return;
                    }
                    
                    // Pr√ºfe ob Spieler am Zug ist
                    if (this.game.currentPlayer !== this.playerColor) {
                        this.toast('‚è≥ Du bist nicht am Zug!');
                        return;
                    }
                    
                    const piece = this.game.board[row][col];
                    
                    // --- FIGUR AUSW√ÑHLEN ---
                    if (!this.game.selectedPiece) {
                        // Nur eigene Figuren ausw√§hlen
                        if (piece && this.game.getPieceColor(piece) === this.playerColor) {
                            this.game.selectedPiece = { row, col };
                            this.game.validMoves = this.game.getValidMoves(row, col);
                            this.renderBoard();
                            return;
                        }
                    } 
                    // --- ZUG AUSF√úHREN ---
                    else {
                        const fromRow = this.game.selectedPiece.row;
                        const fromCol = this.game.selectedPiece.col;
                        
                        // Auswahl aufheben (gleiches Feld)
                        if (row === fromRow && col === fromCol) {
                            this.game.selectedPiece = null;
                            this.game.validMoves = [];
                            this.renderBoard();
                            return;
                        }
                        
                        // Pr√ºfe ob Zielfeld in validMoves ist
                        const isValidMove = this.game.validMoves.some(m => m.row === row && m.col === col);
                        
                        if (isValidMove) {
                            // Zug ausf√ºhren
                            const result = this.game.makeMove(fromRow, fromCol, row, col);
                            
                            if (result.success) {
                                this.isLocalMove = true;
                                
                                // Firebase aktualisieren
                                await this.roomRef.update({
                                    ...this.game.getState(),
                                    lastUpdate: Date.now()
                                });
                                
                                // Auswahl zur√ºcksetzen
                                this.game.selectedPiece = null;
                                this.game.validMoves = [];
                                
                                // Board neu zeichnen
                                this.renderBoard();
                                
                                // Toast bei Spielende
                                if (result.gameOver) {
                                    this.toast(result.result);
                                }
                            } else {
                                this.toast(`‚ùå ${result.error || 'Ung√ºltiger Zug'}`);
                                this.game.selectedPiece = null;
                                this.game.validMoves = [];
                                this.renderBoard();
                            }
                        } else {
                            // Ung√ºltiges Zielfeld - Auswahl zur√ºcksetzen
                            this.game.selectedPiece = null;
                            this.game.validMoves = [];
                            this.renderBoard();
                            this.toast('‚ùå Ung√ºltiger Zug');
                        }
                    }
                });
            }

            toast(msg) {
                const toast = document.getElementById('toast');
                toast.innerText = msg;
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 3000);
            }
        }

        // Controller starten
        const controller = new GameController();
    </script>
</body>
</html>
