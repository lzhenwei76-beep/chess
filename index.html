<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ôî ELOISE ¬∑ Online Schach</title>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', sans-serif;
            background: #0a0c10;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        .game-wrapper {
            max-width: 1400px;
            width: 100%;
            background: #14181c;
            border-radius: 24px;
            padding: 24px;
        }
        .server-bar {
            display: flex;
            justify-content: space-between;
            background: #1e232a;
            padding: 12px 20px;
            border-radius: 100px;
            margin-bottom: 24px;
        }
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .online { background: #2ecc71; box-shadow: 0 0 10px #2ecc71; }
        .offline { background: #e74c3c; box-shadow: 0 0 10px #e74c3c; }
        .connecting { background: #f39c12; box-shadow: 0 0 10px #f39c12; }
        
        .lobby-layout {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 24px;
        }
        .lobby-sidebar {
            background: #1e232a;
            border-radius: 20px;
            padding: 20px;
        }
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 12px;
            background: #2f3542;
            color: white;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
        }
        .btn-primary { background: linear-gradient(135deg, #667eea, #764ba2); }
        .btn-danger { background: #e74c3c; }
        
        .lobby-item {
            background: #232931;
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .join-btn {
            background: #2ecc71;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
        }
        
        .board-container {
            max-width: 560px;
            margin: 0 auto;
            aspect-ratio: 1;
        }
        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            width: 100%;
            height: 100%;
            border: 2px solid #3a4050;
            border-radius: 8px;
            overflow: hidden;
        }
        .square {
            aspect-ratio: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
        }
        .square.light { background: #eadbc5; }
        .square.dark { background: #b08b5c; }
        .square.selected { background: #6b9ac4 !important; }
        .square.possible-move::after {
            content: '';
            width: 20px;
            height: 20px;
            background: rgba(46,204,113,0.7);
            border-radius: 50%;
            position: absolute;
        }
        .square.check { background: #e74c3c !important; }
        
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #1e232a;
            border-left: 4px solid #667eea;
            padding: 16px 24px;
            border-radius: 12px;
            color: white;
            transform: translateX(400px);
            transition: transform 0.3s;
        }
        .toast.show { transform: translateX(0); }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <!-- Server Status -->
        <div class="server-bar">
            <div>
                <span class="status-dot online" id="statusDot"></span>
                <span id="statusText">Verbunden</span>
            </div>
            <div>üì∂ <span id="pingValue">0</span> ms</div>
            <div>üë• <span id="onlineCount">0</span> online</div>
            <div>üéÆ <span id="roomCount">0</span> R√§ume</div>
        </div>

        <!-- Main Layout -->
        <div class="lobby-layout">
            <!-- Lobby -->
            <div class="lobby-sidebar">
                <h2 style="color: white; margin-bottom: 20px;">üéÆ Lobby</h2>
                
                <div style="background: #2a3038; padding: 12px; border-radius: 100px; margin-bottom: 20px;">
                    üë§ <span id="playerNameDisplay" style="color: white;">Name eingeben</span>
                </div>
                
                <input type="text" id="playerNameInput" placeholder="Dein Name" 
                       style="width: 100%; padding: 12px; background: #2a3038; border: none; border-radius: 12px; color: white; margin-bottom: 10px;">
                <button id="saveNameBtn" class="btn btn-primary">Name speichern</button>
                <button id="createRoomBtn" class="btn btn-primary" style="margin-top: 10px;">üåç √ñffentliches Spiel erstellen</button>
                
                <div style="margin-top: 30px;">
                    <h3 style="color: white; margin-bottom: 15px;">üü¢ Verf√ºgbare Spiele</h3>
                    <div id="lobbyList" style="max-height: 400px; overflow-y: auto;"></div>
                </div>
                
                <div id="currentRoomCard" style="display: none; margin-top: 20px; background: #232931; padding: 15px; border-radius: 12px;">
                    <h4 style="color: white; margin-bottom: 10px;">Aktueller Raum</h4>
                    <div id="roomDetails" style="color: #a0b3ff; margin-bottom: 10px;"></div>
                    <button id="leaveRoomBtn" class="btn btn-danger">Raum verlassen</button>
                </div>
            </div>
            
            <!-- Game Area -->
            <div style="background: #1e232a; border-radius: 20px; padding: 20px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 20px;">
                    <div style="background: rgba(102,126,234,0.15); padding: 8px 16px; border-radius: 100px;">
                        üéØ <span id="roomIdDisplay">Kein Raum</span>
                    </div>
                    <button id="resetGameBtn" class="btn" style="width: auto; padding: 8px 20px;">üîÑ Neustart</button>
                </div>
                
                <div class="board-container">
                    <div id="chessboard"></div>
                </div>
                
                <div style="display: flex; gap: 20px; margin-top: 20px;">
                    <div style="flex: 1; background: #232931; padding: 15px; border-radius: 12px;" id="whiteCard">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="font-size: 2em;">‚ôî</div>
                            <div>
                                <div style="color: white; font-weight: 600;" id="whiteName">Wei√ü</div>
                                <div style="color: #8e9aaf;" id="whiteStatus">Wartet...</div>
                            </div>
                        </div>
                    </div>
                    <div style="flex: 1; background: #232931; padding: 15px; border-radius: 12px;" id="blackCard">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="font-size: 2em;">‚ôö</div>
                            <div>
                                <div style="color: white; font-weight: 600;" id="blackName">Schwarz</div>
                                <div style="color: #8e9aaf;" id="blackStatus">Wartet...</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 20px; background: #232931; padding: 15px; border-radius: 12px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span style="color: white;">üìú Zugverlauf</span>
                        <span style="color: #8e9aaf;" id="moveCount">0 Z√ºge</span>
                    </div>
                    <div id="movesList" style="display: grid; grid-template-columns: repeat(2,1fr); gap: 5px; max-height: 150px; overflow-y: auto;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>

    <script>
        // FIREBASE CONFIG
        const firebaseConfig = {
            apiKey: "AIzaSyBg8mOUWGRWCdfiF5RrLoRWQz0DYQE2W2Q",
            authDomain: "schach-a98cc.firebaseapp.com",
            databaseURL: "https://schach-a98cc-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "schach-a98cc",
            storageBucket: "schach-a98cc.firebasestorage.app",
            messagingSenderId: "374332466146",
            appId: "1:374332466146:web:6ff16f969d464136838fbb"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        // ======================
        // SCHACH ENGINE
        // ======================
        class ChessGame {
            constructor() {
                this.reset();
            }

            reset() {
                this.board = [
                    ['‚ôú','‚ôû','‚ôù','‚ôõ','‚ôö','‚ôù','‚ôû','‚ôú'],
                    ['‚ôü','‚ôü','‚ôü','‚ôü','‚ôü','‚ôü','‚ôü','‚ôü'],
                    ['','','','','','','',''],
                    ['','','','','','','',''],
                    ['','','','','','','',''],
                    ['','','','','','','',''],
                    ['‚ôô','‚ôô','‚ôô','‚ôô','‚ôô','‚ôô','‚ôô','‚ôô'],
                    ['‚ôñ','‚ôò','‚ôó','‚ôï','‚ôî','‚ôó','‚ôò','‚ôñ']
                ];
                this.currentPlayer = 'w';
                this.selected = null;
                this.validMoves = [];
                this.gameOver = false;
                this.moveHistory = [];
                this.captured = { w: [], b: [] };
            }

            getColor(piece) {
                if (!piece) return null;
                return piece === piece.toLowerCase() ? 'b' : 'w';
            }

            getType(piece) {
                const types = { '‚ôî':'K','‚ôï':'Q','‚ôñ':'R','‚ôó':'B','‚ôò':'N','‚ôô':'P',
                               '‚ôö':'K','‚ôõ':'Q','‚ôú':'R','‚ôù':'B','‚ôû':'N','‚ôü':'P' };
                return types[piece];
            }

            inBounds(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            getMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];
                const color = this.getColor(piece);
                const type = this.getType(piece);
                let moves = [];

                switch(type) {
                    case 'P':
                        const dir = color === 'w' ? -1 : 1;
                        const start = color === 'w' ? 6 : 1;
                        if (this.inBounds(row+dir, col) && !this.board[row+dir][col]) {
                            moves.push({row: row+dir, col});
                            if (row === start && !this.board[row+2*dir][col]) {
                                moves.push({row: row+2*dir, col});
                            }
                        }
                        for (const dc of [-1,1]) {
                            if (this.inBounds(row+dir, col+dc) && 
                                this.board[row+dir][col+dc] && 
                                this.getColor(this.board[row+dir][col+dc]) !== color) {
                                moves.push({row: row+dir, col: col+dc});
                            }
                        }
                        break;
                        
                    case 'R':
                    case 'Q':
                        const dirs = type === 'R' ? [[-1,0],[1,0],[0,-1],[0,1]] : 
                                                   [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
                        for (const [dr,dc] of dirs) {
                            let r = row+dr, c = col+dc;
                            while (this.inBounds(r,c)) {
                                if (!this.board[r][c]) {
                                    moves.push({row: r, col: c});
                                } else {
                                    if (this.getColor(this.board[r][c]) !== color) moves.push({row: r, col: c});
                                    break;
                                }
                                r += dr; c += dc;
                            }
                        }
                        break;
                        
                    case 'N':
                        const knight = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                        for (const [dr,dc] of knight) {
                            const r = row+dr, c = col+dc;
                            if (this.inBounds(r,c) && (!this.board[r][c] || this.getColor(this.board[r][c]) !== color)) {
                                moves.push({row: r, col: c});
                            }
                        }
                        break;
                        
                    case 'B':
                        const bdirs = [[-1,-1],[-1,1],[1,-1],[1,1]];
                        for (const [dr,dc] of bdirs) {
                            let r = row+dr, c = col+dc;
                            while (this.inBounds(r,c)) {
                                if (!this.board[r][c]) {
                                    moves.push({row: r, col: c});
                                } else {
                                    if (this.getColor(this.board[r][c]) !== color) moves.push({row: r, col: c});
                                    break;
                                }
                                r += dr; c += dc;
                            }
                        }
                        break;
                        
                    case 'K':
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                if (dr === 0 && dc === 0) continue;
                                const r = row+dr, c = col+dc;
                                if (this.inBounds(r,c) && (!this.board[r][c] || this.getColor(this.board[r][c]) !== color)) {
                                    moves.push({row: r, col: c});
                                }
                            }
                        }
                        break;
                }
                
                // Filter moves that would leave king in check
                return moves.filter(m => !this.isCheck(color, this.simulate(row, col, m.row, m.col)));
            }

            simulate(fromRow, fromCol, toRow, toCol) {
                const newBoard = this.board.map(r => [...r]);
                newBoard[toRow][toCol] = newBoard[fromRow][fromCol];
                newBoard[fromRow][fromCol] = '';
                return newBoard;
            }

            isCheck(color, board = this.board) {
                const king = color === 'w' ? '‚ôî' : '‚ôö';
                let kr = -1, kc = -1;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] === king) { kr = r; kc = c; break; }
                    }
                    if (kr !== -1) break;
                }
                if (kr === -1) return false;
                
                const opp = color === 'w' ? 'b' : 'w';
                
                // Pawns
                const pdir = color === 'w' ? 1 : -1;
                for (const dc of [-1,1]) {
                    if (this.inBounds(kr+pdir, kc+dc) && board[kr+pdir][kc+dc] && 
                        this.getColor(board[kr+pdir][kc+dc]) === opp &&
                        (board[kr+pdir][kc+dc] === '‚ôô' || board[kr+pdir][kc+dc] === '‚ôü')) return true;
                }
                
                // Knights
                const knightM = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                for (const [dr,dc] of knightM) {
                    if (this.inBounds(kr+dr, kc+dc) && board[kr+dr][kc+dc] &&
                        this.getColor(board[kr+dr][kc+dc]) === opp &&
                        (board[kr+dr][kc+dc] === '‚ôò' || board[kr+dr][kc+dc] === '‚ôû')) return true;
                }
                
                // Rooks/Queens
                const rookD = [[-1,0],[1,0],[0,-1],[0,1]];
                for (const [dr,dc] of rookD) {
                    let r = kr+dr, c = kc+dc;
                    while (this.inBounds(r,c)) {
                        if (board[r][c]) {
                            if (this.getColor(board[r][c]) === opp && 
                                (board[r][c] === '‚ôñ' || board[r][c] === '‚ôú' || 
                                 board[r][c] === '‚ôï' || board[r][c] === '‚ôõ')) return true;
                            break;
                        }
                        r += dr; c += dc;
                    }
                }
                
                // Bishops/Queens
                const bishopD = [[-1,-1],[-1,1],[1,-1],[1,1]];
                for (const [dr,dc] of bishopD) {
                    let r = kr+dr, c = kc+dc;
                    while (this.inBounds(r,c)) {
                        if (board[r][c]) {
                            if (this.getColor(board[r][c]) === opp && 
                                (board[r][c] === '‚ôó' || board[r][c] === '‚ôù' || 
                                 board[r][c] === '‚ôï' || board[r][c] === '‚ôõ')) return true;
                            break;
                        }
                        r += dr; c += dc;
                    }
                }
                
                return false;
            }

            isCheckmate(color) {
                if (!this.isCheck(color)) return false;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (this.board[r][c] && this.getColor(this.board[r][c]) === color) {
                            if (this.getMoves(r,c).length > 0) return false;
                        }
                    }
                }
                return true;
            }

            move(fromRow, fromCol, toRow, toCol) {
                const moves = this.getMoves(fromRow, fromCol);
                if (!moves.some(m => m.row === toRow && m.col === toCol)) return false;
                
                const piece = this.board[fromRow][fromCol];
                const target = this.board[toRow][toCol];
                const color = this.getColor(piece);
                
                if (target) this.captured[color === 'w' ? 'b' : 'w'].push(target);
                
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = '';
                
                // Pawn promotion
                if (this.getType(piece) === 'P' && (toRow === 0 || toRow === 7)) {
                    this.board[toRow][toCol] = color === 'w' ? '‚ôï' : '‚ôõ';
                }
                
                // Notation
                const cols = ['a','b','c','d','e','f','g','h'];
                const rows = ['8','7','6','5','4','3','2','1'];
                let notation = '';
                if (this.getType(piece) === 'P') {
                    if (target) notation += cols[fromCol];
                } else {
                    notation += this.getType(piece);
                }
                if (target) notation += 'x';
                notation += cols[toCol] + rows[toRow];
                this.moveHistory.push(notation);
                
                this.currentPlayer = color === 'w' ? 'b' : 'w';
                
                if (this.isCheckmate(this.currentPlayer)) {
                    this.gameOver = true;
                    return { success: true, gameOver: true, result: `${this.currentPlayer === 'w' ? 'Schwarz' : 'Wei√ü'} gewinnt!` };
                }
                
                return { success: true, gameOver: false };
            }
        }

        // ======================
        // MAIN CONTROLLER
        // ======================
        class GameController {
            constructor() {
                this.game = new ChessGame();
                this.playerName = localStorage.getItem('chess_name') || '';
                this.playerId = 'p_' + Math.random().toString(36).substring(2, 10);
                this.currentRoom = null;
                this.playerColor = null;
                this.roomRef = null;
                
                this.initUI();
                this.initFirebase();
                this.renderBoard();
            }

            initUI() {
                document.getElementById('playerNameDisplay').innerText = this.playerName || 'Kein Name';
                document.getElementById('playerNameInput').value = this.playerName;
                
                document.getElementById('saveNameBtn').onclick = () => {
                    const name = document.getElementById('playerNameInput').value.trim();
                    if (name) {
                        this.playerName = name;
                        localStorage.setItem('chess_name', name);
                        document.getElementById('playerNameDisplay').innerText = name;
                        this.toast('‚úÖ Name gespeichert');
                    }
                };
                
                document.getElementById('createRoomBtn').onclick = () => this.createRoom();
                document.getElementById('leaveRoomBtn').onclick = () => this.leaveRoom();
                document.getElementById('resetGameBtn').onclick = () => this.resetGame();
                
                // Ping alle 1 Sekunde
                setInterval(() => {
                    const start = Date.now();
                    db.ref('.info/serverTimeOffset').once('value').then(() => {
                        const ping = Date.now() - start;
                        document.getElementById('pingValue').innerText = ping;
                    });
                }, 1000);
                
                // Online Players
                db.ref('presence').on('value', (snap) => {
                    let online = 0;
                    if (snap.val()) {
                        Object.values(snap.val()).forEach(p => {
                            if (p.online && Date.now() - p.lastSeen < 120000) online++;
                        });
                    }
                    document.getElementById('onlineCount').innerText = online;
                });
                
                // Room Count
                db.ref('rooms').on('value', (snap) => {
                    if (snap.val()) {
                        const count = Object.keys(snap.val()).length;
                        document.getElementById('roomCount').innerText = count;
                    }
                });
            }

            initFirebase() {
                const connected = db.ref('.info/connected');
                connected.on('value', (snap) => {
                    if (snap.val()) {
                        document.getElementById('statusDot').className = 'status-dot online';
                        document.getElementById('statusText').innerText = 'Verbunden';
                        this.initPresence();
                    } else {
                        document.getElementById('statusDot').className = 'status-dot offline';
                        document.getElementById('statusText').innerText = 'Offline';
                    }
                });
                
                // Lobby Listener
                db.ref('rooms').on('value', (snap) => {
                    this.updateLobby(snap.val());
                });
            }

            initPresence() {
                const presence = db.ref('presence/' + this.playerId);
                presence.set({
                    name: this.playerName,
                    online: true,
                    lastSeen: Date.now(),
                    currentRoom: this.currentRoom
                });
                presence.onDisconnect().update({
                    online: false,
                    lastSeen: Date.now()
                });
            }

            updateLobby(rooms) {
                const list = document.getElementById('lobbyList');
                if (!rooms) {
                    list.innerHTML = '<div style="color: #8e9aaf; text-align: center; padding: 20px;">Keine offenen Spiele</div>';
                    return;
                }
                
                let html = '';
                Object.entries(rooms).forEach(([id, room]) => {
                    // WICHTIG: Korrekte Pr√ºfung f√ºr verf√ºgbare R√§ume
                    if (room.isPublic === true && 
                        room.players && 
                        room.players.w && 
                        (!room.players.b || room.players.b === null) &&
                        room.creatorId !== this.playerId && // Nicht eigener Raum
                        id !== this.currentRoom) { // Nicht aktueller Raum
                        
                        html += `
                            <div class="lobby-item">
                                <div>
                                    <div style="color: #a0b3ff; font-size: 0.9em;">üë§ ${room.creatorName || 'Spieler'}</div>
                                    <div style="color: white;">${room.name || 'Schachspiel'}</div>
                                    <div style="color: #8e9aaf; font-size: 0.8em;">‚ö° ${Math.floor((Date.now() - (room.created || Date.now()))/60000)} min</div>
                                </div>
                                <button class="join-btn" onclick="controller.joinRoom('${id}')">Beitreten</button>
                            </div>
                        `;
                    }
                });
                
                list.innerHTML = html || '<div style="color: #8e9aaf; text-align: center; padding: 20px;">Keine offenen Spiele</div>';
            }

            async createRoom() {
                if (!this.playerName) {
                    this.toast('‚ùå Bitte erst Namen eingeben!');
                    return;
                }
                
                const roomId = 'game-' + Math.random().toString(36).substring(2, 8);
                this.currentRoom = roomId;
                this.playerColor = 'w';
                this.roomRef = db.ref('rooms/' + roomId);
                
                const roomData = {
                    isPublic: true,
                    name: `Spiel von ${this.playerName}`,
                    creatorId: this.playerId,
                    creatorName: this.playerName,
                    players: {
                        w: {
                            id: this.playerId,
                            name: this.playerName,
                            connected: true
                        },
                        b: null  // WICHTIG: null = frei
                    },
                    board: this.game.board,
                    currentPlayer: 'w',
                    gameOver: false,
                    moveHistory: [],
                    capturedPieces: { w: [], b: [] },
                    created: Date.now(),
                    lastUpdate: Date.now()
                };
                
                await this.roomRef.set(roomData);
                
                // Presence updaten
                db.ref('presence/' + this.playerId).update({ currentRoom: roomId });
                
                // UI updaten
                document.getElementById('roomIdDisplay').innerText = roomId;
                document.getElementById('currentRoomCard').style.display = 'block';
                document.getElementById('roomDetails').innerHTML = `
                    üåç √ñffentliches Spiel<br>
                    ID: ${roomId}<br>
                    Du: Wei√ü (${this.playerName})
                `;
                
                document.getElementById('whiteName').innerHTML = `Wei√ü <span style="color: #2ecc71;">‚óè ${this.playerName}</span>`;
                document.getElementById('whiteStatus').innerText = 'Aktiv';
                document.getElementById('blackName').innerText = 'Schwarz';
                document.getElementById('blackStatus').innerText = 'Wartet...';
                
                this.setupRoomListener();
                this.toast('üåç Spiel erstellt! Warte auf Gegner...');
            }

            async joinRoom(roomId) {
                if (!this.playerName) {
                    this.toast('‚ùå Bitte erst Namen eingeben!');
                    return;
                }
                
                const roomRef = db.ref('rooms/' + roomId);
                const snap = await roomRef.get();
                if (!snap.exists()) {
                    this.toast('‚ùå Raum nicht gefunden!');
                    return;
                }
                
                const room = snap.val();
                
                // WICHTIG: Korrekte Pr√ºfung ob Platz frei ist
                if (room.players && room.players.b && room.players.b !== null) {
                    this.toast('‚ùå Dieser Raum ist bereits voll!');
                    return;
                }
                
                this.currentRoom = roomId;
                this.playerColor = 'b';
                this.roomRef = roomRef;
                
                // Board-State vom Ersteller √ºbernehmen
                this.game.board = room.board || this.game.board;
                this.game.currentPlayer = room.currentPlayer || 'w';
                this.game.moveHistory = room.moveHistory || [];
                this.game.captured = room.capturedPieces || { w: [], b: [] };
                
                await roomRef.update({
                    'players/b': {
                        id: this.playerId,
                        name: this.playerName,
                        connected: true
                    },
                    lastUpdate: Date.now()
                });
                
                // Presence updaten
                db.ref('presence/' + this.playerId).update({ currentRoom: roomId });
                
                // UI updaten
                document.getElementById('roomIdDisplay').innerText = roomId;
                document.getElementById('currentRoomCard').style.display = 'block';
                document.getElementById('roomDetails').innerHTML = `
                    üåç √ñffentliches Spiel<br>
                    ID: ${roomId}<br>
                    Du: Schwarz (${this.playerName})<br>
                    Gegner: ${room.creatorName || 'Wei√ü'}
                `;
                
                document.getElementById('whiteName').innerHTML = `Wei√ü <span style="color: #2ecc71;">‚óè ${room.creatorName || 'Spieler'}</span>`;
                document.getElementById('whiteStatus').innerText = 'Aktiv';
                document.getElementById('blackName').innerHTML = `Schwarz <span style="color: #2ecc71;">‚óè ${this.playerName}</span>`;
                document.getElementById('blackStatus').innerText = 'Aktiv';
                
                this.setupRoomListener();
                this.renderBoard();
                this.toast('‚úÖ Raum beigetreten!');
            }

            setupRoomListener() {
                if (!this.roomRef) return;
                
                this.roomRef.on('value', (snap) => {
                    if (!snap.exists()) {
                        this.toast('üèÅ Raum wurde geschlossen');
                        this.leaveRoom(true);
                        return;
                    }
                    
                    const data = snap.val();
                    
                    // Board aktualisieren
                    if (data.board) {
                        this.game.board = data.board;
                        this.game.currentPlayer = data.currentPlayer || 'w';
                        this.game.gameOver = data.gameOver || false;
                        this.game.moveHistory = data.moveHistory || [];
                        this.renderBoard();
                    }
                    
                    // Spieler-Status aktualisieren
                    if (data.players) {
                        if (data.players.w) {
                            document.getElementById('whiteName').innerHTML = 
                                `Wei√ü <span style="color: #2ecc71;">‚óè ${data.players.w.name || 'Spieler'}</span>`;
                        }
                        if (data.players.b) {
                            document.getElementById('blackName').innerHTML = 
                                `Schwarz <span style="color: #2ecc71;">‚óè ${data.players.b.name || 'Spieler'}</span>`;
                            document.getElementById('blackStatus').innerText = 'Aktiv';
                        } else {
                            document.getElementById('blackName').innerText = 'Schwarz';
                            document.getElementById('blackStatus').innerText = 'Wartet...';
                        }
                    }
                });
            }

            async leaveRoom(silent = false) {
                if (this.roomRef) {
                    if (this.playerColor === 'w') {
                        await this.roomRef.remove();
                    } else {
                        await this.roomRef.update({
                            'players/b': null,
                            lastUpdate: Date.now()
                        });
                    }
                    this.roomRef.off();
                }
                
                db.ref('presence/' + this.playerId).update({ currentRoom: null });
                
                this.currentRoom = null;
                this.playerColor = null;
                this.roomRef = null;
                this.game.reset();
                
                document.getElementById('roomIdDisplay').innerText = 'Kein Raum';
                document.getElementById('currentRoomCard').style.display = 'none';
                document.getElementById('whiteName').innerHTML = 'Wei√ü';
                document.getElementById('whiteStatus').innerText = 'Wartet...';
                document.getElementById('blackName').innerHTML = 'Schwarz';
                document.getElementById('blackStatus').innerText = 'Wartet...';
                
                this.renderBoard();
                if (!silent) this.toast('üëã Raum verlassen');
            }

            async resetGame() {
                if (!this.currentRoom) {
                    this.toast('‚ùå Kein Raum verbunden!');
                    return;
                }
                if (this.playerColor !== 'w') {
                    this.toast('‚ùå Nur Wei√ü kann neustarten!');
                    return;
                }
                
                this.game.reset();
                await this.roomRef.update({
                    ...this.game,
                    lastUpdate: Date.now()
                });
                this.toast('‚ú® Neues Spiel gestartet!');
            }

            renderBoard() {
                const board = document.getElementById('chessboard');
                board.innerHTML = '';
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const square = document.createElement('div');
                        square.className = `square ${(r+c) % 2 === 0 ? 'light' : 'dark'}`;
                        if (this.game.board[r][c]) square.textContent = this.game.board[r][c];
                        
                        if (this.game.selected && this.game.selected.r === r && this.game.selected.c === c) {
                            square.classList.add('selected');
                        }
                        
                        if (this.game.validMoves.some(m => m.row === r && m.col === c)) {
                            square.classList.add('possible-move');
                        }
                        
                        if (this.game.isCheck(this.game.currentPlayer === 'w' ? 'b' : 'w')) {
                            const king = this.game.currentPlayer === 'w' ? '‚ôö' : '‚ôî';
                            if (this.game.board[r][c] === king) square.classList.add('check');
                        }
                        
                        square.onclick = () => this.handleClick(r, c);
                        board.appendChild(square);
                    }
                }
                
                document.getElementById('moveCount').innerText = `${this.game.moveHistory.length} Z√ºge`;
                
                const moves = document.getElementById('movesList');
                moves.innerHTML = '';
                this.game.moveHistory.forEach((move, i) => {
                    const div = document.createElement('div');
                    div.className = 'move-entry';
                    div.style.cssText = 'background: #1a1e24; padding: 5px 10px; border-radius: 5px; color: #e1e9f0;';
                    if (i % 2 === 0) div.innerHTML = `<strong>${Math.floor(i/2)+1}.</strong> ${move}`;
                    else div.innerText = move;
                    moves.appendChild(div);
                });
                
                document.getElementById('whiteCard').classList.toggle('active', this.game.currentPlayer === 'w');
                document.getElementById('blackCard').classList.toggle('active', this.game.currentPlayer === 'b');
            }

            handleClick(row, col) {
                if (!this.currentRoom) {
                    this.toast('üéÆ Erst Raum erstellen/beitreten!');
                    return;
                }
                if (this.game.gameOver) {
                    this.toast('üèÅ Spiel beendet!');
                    return;
                }
                
                this.roomRef.once('value').then(async (snap) => {
                    const data = snap.val();
                    if (!data.players || !data.players.b) {
                        this.toast('‚è≥ Warte auf Gegner...');
                        return;
                    }
                    
                    if (this.game.currentPlayer !== this.playerColor) {
                        this.toast('‚è≥ Du bist nicht am Zug!');
                        return;
                    }
                    
                    const piece = this.game.board[row][col];
                    
                    if (!this.game.selected && piece && this.game.getColor(piece) === this.playerColor) {
                        this.game.selected = { r: row, c: col };
                        this.game.validMoves = this.game.getMoves(row, col);
                        this.renderBoard();
                        return;
                    }
                    
                    if (this.game.selected) {
                        const fromR = this.game.selected.r;
                        const fromC = this.game.selected.c;
                        
                        if (row === fromR && col === fromC) {
                            this.game.selected = null;
                            this.game.validMoves = [];
                            this.renderBoard();
                            return;
                        }
                        
                        const result = this.game.move(fromR, fromC, row, col);
                        if (result.success) {
                            await this.roomRef.update({
                                board: this.game.board,
                                currentPlayer: this.game.currentPlayer,
                                gameOver: this.game.gameOver,
                                moveHistory: this.game.moveHistory,
                                capturedPieces: this.game.captured,
                                lastUpdate: Date.now()
                            });
                            
                            this.game.selected = null;
                            this.game.validMoves = [];
                            this.renderBoard();
                            
                            if (result.gameOver) this.toast(result.result);
                        }
                    }
                });
            }

            toast(msg) {
                const toast = document.getElementById('toast');
                toast.innerText = msg;
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 3000);
            }
        }

        window.controller = new GameController();
    </script>
</body>
</html>
