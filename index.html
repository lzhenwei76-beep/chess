<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ôî ELOISE ¬∑ Online Schach</title>
    
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', sans-serif;
            background: #0a0c10;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        .game-wrapper {
            max-width: 1400px;
            width: 100%;
            background: #14181c;
            border-radius: 24px;
            padding: 24px;
        }
        .server-bar {
            display: flex;
            justify-content: space-between;
            background: #1e232a;
            padding: 12px 20px;
            border-radius: 100px;
            margin-bottom: 24px;
        }
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        .online { background: #2ecc71; box-shadow: 0 0 10px #2ecc71; animation: pulse 2s infinite; }
        .offline { background: #e74c3c; box-shadow: 0 0 10px #e74c3c; }
        .connecting { background: #f39c12; box-shadow: 0 0 10px #f39c12; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
        
        .lobby-layout {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 24px;
        }
        .lobby-sidebar {
            background: #1e232a;
            border-radius: 20px;
            padding: 20px;
        }
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 12px;
            background: #2f3542;
            color: white;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.2s;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .btn-primary { background: linear-gradient(135deg, #667eea, #764ba2); }
        .btn-danger { background: #e74c3c; }
        .btn-success { background: #2ecc71; }
        .btn-warning { background: #f39c12; color: black; }
        
        .lobby-item {
            background: #232931;
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 4px solid #2ecc71;
        }
        .lobby-item.full {
            border-left-color: #e74c3c;
            opacity: 0.7;
        }
        .join-btn {
            background: #2ecc71;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
        }
        .join-btn:hover { background: #27ae60; }
        .join-btn.disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }
        
        .board-container {
            max-width: 560px;
            margin: 0 auto;
            aspect-ratio: 1;
        }
        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            width: 100%;
            height: 100%;
            border: 2px solid #3a4050;
            border-radius: 8px;
            overflow: hidden;
        }
        .square {
            aspect-ratio: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.2em;
            cursor: pointer;
            position: relative;
            transition: all 0.1s;
        }
        .square.light { background: #eadbc5; }
        .square.dark { background: #b08b5c; }
        .square.selected { background: #6b9ac4 !important; box-shadow: inset 0 0 0 3px #ffd966; }
        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 25px;
            height: 25px;
            background: rgba(46, 204, 113, 0.8);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.5);
        }
        .square.check { background: #e74c3c !important; box-shadow: inset 0 0 0 3px #ffd700; }
        .square:hover { filter: brightness(1.1); transform: scale(0.98); }
        
        .player-card {
            flex: 1;
            background: #232931;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid transparent;
        }
        .player-card.active {
            border: 2px solid #667eea;
            background: linear-gradient(145deg, #2a3140, #1e232c);
            box-shadow: 0 0 20px rgba(102,126,234,0.2);
        }
        .player-card.connected {
            border-left: 4px solid #2ecc71;
        }
        
        .connection-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 100px;
            font-size: 0.7em;
            font-weight: 600;
            margin-left: 8px;
        }
        .badge-online { background: #2ecc71; color: white; }
        .badge-offline { background: #7f8c8d; color: white; }
        .badge-waiting { background: #f39c12; color: black; }
        
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #1e232a;
            border-left: 4px solid #667eea;
            padding: 16px 24px;
            border-radius: 12px;
            color: white;
            transform: translateX(400px);
            transition: transform 0.3s;
            z-index: 9999;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .toast.show { transform: translateX(0); }
        .toast.success { border-left-color: #2ecc71; }
        .toast.error { border-left-color: #e74c3c; }
        .toast.warning { border-left-color: #f39c12; }
        
        .debug-panel {
            margin-top: 20px;
            padding: 15px;
            background: #1a1e24;
            border-radius: 12px;
            border-left: 4px solid #f39c12;
        }
        .debug-panel h4 {
            color: #f39c12;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .debug-log {
            background: #0f1115;
            padding: 10px;
            border-radius: 8px;
            color: #e1e9f0;
            font-family: monospace;
            font-size: 0.8em;
            max-height: 150px;
            overflow-y: auto;
        }
        .room-status {
            background: #2a3038;
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            color: white;
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <!-- Server Status -->
        <div class="server-bar">
            <div>
                <span class="status-dot online" id="statusDot"></span>
                <span id="statusText">Verbinde...</span>
            </div>
            <div>üì∂ <span id="pingValue">0</span> ms</div>
            <div>üë• <span id="onlineCount">0</span> online</div>
            <div>üéÆ <span id="roomCount">0</span> R√§ume</div>
        </div>

        <!-- Main Layout -->
        <div class="lobby-layout">
            <!-- Lobby -->
            <div class="lobby-sidebar">
                <h2 style="color: white; margin-bottom: 20px;">üéÆ Lobby</h2>
                
                <div style="background: #2a3038; padding: 12px; border-radius: 100px; margin-bottom: 20px;">
                    üë§ <span id="playerNameDisplay" style="color: white;">Name eingeben</span>
                </div>
                
                <input type="text" id="playerNameInput" placeholder="Dein Name" 
                       style="width: 100%; padding: 12px; background: #2a3038; border: none; border-radius: 12px; color: white; margin-bottom: 10px;">
                <button id="saveNameBtn" class="btn btn-primary">Name speichern</button>
                <button id="createRoomBtn" class="btn btn-primary" style="margin-top: 10px;">üåç √ñffentliches Spiel erstellen</button>
                
                <!-- Raum Status Anzeige -->
                <div id="roomStatusCard" style="display: none; margin-top: 20px; background: #232931; padding: 15px; border-radius: 12px;">
                    <h4 style="color: white; margin-bottom: 10px;">üéØ Aktueller Raum</h4>
                    <div id="roomStatus" class="room-status">
                        <div style="display: flex; justify-content: space-between;">
                            <span>Raum ID:</span>
                            <span style="color: #a0b3ff;" id="roomIdDisplay">-</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 8px;">
                            <span>Deine Farbe:</span>
                            <span style="color: #2ecc71; font-weight: 600;" id="playerColorDisplay">-</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 8px;">
                            <span>Gegner:</span>
                            <span id="opponentDisplay" style="color: #8e9aaf;">Wartet...</span>
                        </div>
                    </div>
                    <button id="leaveRoomBtn" class="btn btn-danger" style="margin-top: 10px; margin-bottom: 0;">
                        üö™ Raum verlassen
                    </button>
                </div>
                
                <!-- Verf√ºgbare Spiele -->
                <div style="margin-top: 20px;">
                    <h3 style="color: white; margin-bottom: 15px;">üü¢ Verf√ºgbare Spiele</h3>
                    <div id="lobbyList" style="max-height: 300px; overflow-y: auto;"></div>
                </div>
                
                <!-- DEBUG PANEL -->
                <div class="debug-panel">
                    <h4>üêû DEBUG KONSOLE</h4>
                    <div class="debug-log" id="debugLog">
                        [System] Debug-Modus aktiv<br>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                        <button id="debugMoveE4Btn" class="btn btn-warning" style="margin-bottom: 0;">‚ôô e2->e4</button>
                        <button id="debugMoveKnightBtn" class="btn btn-warning" style="margin-bottom: 0;">‚ôò g1->f3</button>
                    </div>
                </div>
            </div>
            
            <!-- Game Area -->
            <div style="background: #1e232a; border-radius: 20px; padding: 20px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 20px;">
                    <div style="background: rgba(102,126,234,0.15); padding: 8px 16px; border-radius: 100px;">
                        üéØ <span id="gameRoomDisplay">Kein Raum</span>
                    </div>
                    <button id="resetGameBtn" class="btn" style="width: auto; padding: 8px 20px;">üîÑ Neustart</button>
                </div>
                
                <div class="board-container">
                    <div id="chessboard"></div>
                </div>
                
                <!-- Player Cards mit Verbindungsstatus -->
                <div style="display: flex; gap: 20px; margin-top: 20px;">
                    <div class="player-card" id="whiteCard">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="font-size: 2em;">‚ôî</div>
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="color: white; font-weight: 600;" id="whiteName">Wei√ü</span>
                                    <span id="whiteStatusBadge" class="connection-badge badge-waiting">‚è≥</span>
                                </div>
                                <div style="color: #8e9aaf; font-size: 0.8em;" id="whiteStatusText">Wartet...</div>
                            </div>
                        </div>
                    </div>
                    <div class="player-card" id="blackCard">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="font-size: 2em;">‚ôö</div>
                            <div style="flex: 1;">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="color: white; font-weight: 600;" id="blackName">Schwarz</span>
                                    <span id="blackStatusBadge" class="connection-badge badge-waiting">‚è≥</span>
                                </div>
                                <div style="color: #8e9aaf; font-size: 0.8em;" id="blackStatusText">Wartet...</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Move History -->
                <div style="margin-top: 20px; background: #232931; padding: 15px; border-radius: 12px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span style="color: white;">üìú Zugverlauf</span>
                        <span style="color: #8e9aaf;" id="moveCount">0 Z√ºge</span>
                    </div>
                    <div id="movesList" style="display: grid; grid-template-columns: repeat(2,1fr); gap: 5px; max-height: 150px; overflow-y: auto;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>

    <script>
        // =========================================
        // FIREBASE KONFIGURATION
        // =========================================
        const firebaseConfig = {
            apiKey: "AIzaSyBg8mOUWGRWCdfiF5RrLoRWQz0DYQE2W2Q",
            authDomain: "schach-a98cc.firebaseapp.com",
            databaseURL: "https://schach-a98cc-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "schach-a98cc",
            storageBucket: "schach-a98cc.firebasestorage.app",
            messagingSenderId: "374332466146",
            appId: "1:374332466146:web:6ff16f969d464136838fbb"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        // =========================================
        // DEBUG LOGGER
        // =========================================
        class DebugLogger {
            constructor() {
                this.logElement = document.getElementById('debugLog');
                this.logs = [];
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'move' ? 'üéØ' : type === 'room' ? 'üè†' : 'üîç';
                const logMessage = `[${timestamp}] ${prefix} ${message}`;
                
                this.logs.push(logMessage);
                if (this.logs.length > 8) this.logs.shift();
                
                this.logElement.innerHTML = this.logs.map(log => log).join('<br>');
                console.log(`${prefix} ${message}`);
            }

            clear() {
                this.logs = [];
                this.logElement.innerHTML = '[System] Debug-Log geleert<br>';
            }
        }

        const debug = new DebugLogger();

        // =========================================
        // SCHACH ENGINE
        // =========================================
        class ChessEngine {
            constructor() {
                this.reset();
            }

            reset() {
                this.board = [
                    ['‚ôú', '‚ôû', '‚ôù', '‚ôõ', '‚ôö', '‚ôù', '‚ôû', '‚ôú'],
                    ['‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü', '‚ôü'],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô', '‚ôô'],
                    ['‚ôñ', '‚ôò', '‚ôó', '‚ôï', '‚ôî', '‚ôó', '‚ôò', '‚ôñ']
                ];
                this.currentPlayer = 'w';
                this.selectedPiece = null;
                this.validMoves = [];
                this.gameOver = false;
                this.moveHistory = [];
                this.capturedPieces = { w: [], b: [] };
            }

            getPieceColor(piece) {
                if (!piece) return null;
                return piece === piece.toLowerCase() ? 'b' : 'w';
            }

            getPieceType(piece) {
                if (!piece) return null;
                const types = {
                    '‚ôî': 'K', '‚ôï': 'Q', '‚ôñ': 'R', '‚ôó': 'B', '‚ôò': 'N', '‚ôô': 'P',
                    '‚ôö': 'K', '‚ôõ': 'Q', '‚ôú': 'R', '‚ôù': 'B', '‚ôû': 'N', '‚ôü': 'P'
                };
                return types[piece];
            }

            isInBounds(row, col) {
                return row >= 0 && row < 8 && col >= 0 && col < 8;
            }

            getValidMoves(row, col) {
                const piece = this.board[row][col];
                if (!piece) return [];
                
                const color = this.getPieceColor(piece);
                const type = this.getPieceType(piece);
                let moves = [];

                switch (type) {
                    case 'P': moves = this.getPawnMoves(row, col, color); break;
                    case 'R': moves = this.getRookMoves(row, col, color); break;
                    case 'N': moves = this.getKnightMoves(row, col, color); break;
                    case 'B': moves = this.getBishopMoves(row, col, color); break;
                    case 'Q': moves = this.getQueenMoves(row, col, color); break;
                    case 'K': moves = this.getKingMoves(row, col, color); break;
                }

                return moves.filter(move => {
                    const newBoard = this.simulateMove(row, col, move.row, move.col);
                    return !this.isInCheck(color, newBoard);
                });
            }

            getPawnMoves(row, col, color) {
                const moves = [];
                const direction = color === 'w' ? -1 : 1;
                const startRow = color === 'w' ? 6 : 1;

                if (this.isInBounds(row + direction, col) && !this.board[row + direction][col]) {
                    moves.push({ row: row + direction, col });
                    if (row === startRow && !this.board[row + 2 * direction][col]) {
                        moves.push({ row: row + 2 * direction, col });
                    }
                }

                for (const dCol of [-1, 1]) {
                    const newRow = row + direction;
                    const newCol = col + dCol;
                    if (this.isInBounds(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (targetPiece && this.getPieceColor(targetPiece) !== color) {
                            moves.push({ row: newRow, col: newCol, capture: true });
                        }
                    }
                }
                return moves;
            }

            getRookMoves(row, col, color) {
                const moves = [];
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                for (const [dRow, dCol] of directions) {
                    let newRow = row + dRow;
                    let newCol = col + dCol;
                    while (this.isInBounds(newRow, newCol)) {
                        if (!this.board[newRow][newCol]) {
                            moves.push({ row: newRow, col: newCol });
                        } else {
                            if (this.getPieceColor(this.board[newRow][newCol]) !== color) {
                                moves.push({ row: newRow, col: newCol, capture: true });
                            }
                            break;
                        }
                        newRow += dRow;
                        newCol += dCol;
                    }
                }
                return moves;
            }

            getKnightMoves(row, col, color) {
                const moves = [];
                const offsets = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
                for (const [dRow, dCol] of offsets) {
                    const newRow = row + dRow;
                    const newCol = col + dCol;
                    if (this.isInBounds(newRow, newCol)) {
                        const targetPiece = this.board[newRow][newCol];
                        if (!targetPiece) {
                            moves.push({ row: newRow, col: newCol });
                        } else if (this.getPieceColor(targetPiece) !== color) {
                            moves.push({ row: newRow, col: newCol, capture: true });
                        }
                    }
                }
                return moves;
            }

            getBishopMoves(row, col, color) {
                const moves = [];
                const directions = [[-1,-1], [-1,1], [1,-1], [1,1]];
                for (const [dRow, dCol] of directions) {
                    let newRow = row + dRow;
                    let newCol = col + dCol;
                    while (this.isInBounds(newRow, newCol)) {
                        if (!this.board[newRow][newCol]) {
                            moves.push({ row: newRow, col: newCol });
                        } else {
                            if (this.getPieceColor(this.board[newRow][newCol]) !== color) {
                                moves.push({ row: newRow, col: newCol, capture: true });
                            }
                            break;
                        }
                        newRow += dRow;
                        newCol += dCol;
                    }
                }
                return moves;
            }

            getQueenMoves(row, col, color) {
                return [...this.getRookMoves(row, col, color), ...this.getBishopMoves(row, col, color)];
            }

            getKingMoves(row, col, color) {
                const moves = [];
                for (let dRow = -1; dRow <= 1; dRow++) {
                    for (let dCol = -1; dCol <= 1; dCol++) {
                        if (dRow === 0 && dCol === 0) continue;
                        const newRow = row + dRow;
                        const newCol = col + dCol;
                        if (this.isInBounds(newRow, newCol)) {
                            const targetPiece = this.board[newRow][newCol];
                            if (!targetPiece) {
                                moves.push({ row: newRow, col: newCol });
                            } else if (this.getPieceColor(targetPiece) !== color) {
                                moves.push({ row: newRow, col: newCol, capture: true });
                            }
                        }
                    }
                }
                return moves;
            }

            simulateMove(fromRow, fromCol, toRow, toCol) {
                const newBoard = this.board.map(row => [...row]);
                newBoard[toRow][toCol] = newBoard[fromRow][fromCol];
                newBoard[fromRow][fromCol] = '';
                return newBoard;
            }

            isInCheck(color, board = this.board) {
                const kingSymbol = color === 'w' ? '‚ôî' : '‚ôö';
                let kingRow = -1, kingCol = -1;
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        if (board[row][col] === kingSymbol) {
                            kingRow = row;
                            kingCol = col;
                            break;
                        }
                    }
                    if (kingRow !== -1) break;
                }
                if (kingRow === -1) return false;
                
                const attackingColor = color === 'w' ? 'b' : 'w';
                
                // Pr√ºfe Bauern
                const pawnDirection = color === 'w' ? 1 : -1;
                for (const dCol of [-1, 1]) {
                    const newRow = kingRow + pawnDirection;
                    const newCol = kingCol + dCol;
                    if (this.isInBounds(newRow, newCol)) {
                        const piece = board[newRow][newCol];
                        if (piece && this.getPieceColor(piece) === attackingColor && 
                            (piece === '‚ôô' || piece === '‚ôü')) {
                            return true;
                        }
                    }
                }
                
                // Pr√ºfe Springer
                const knightMoves = [[-2,-1], [-2,1], [-1,-2], [-1,2], [1,-2], [1,2], [2,-1], [2,1]];
                for (const [dRow, dCol] of knightMoves) {
                    const newRow = kingRow + dRow;
                    const newCol = kingCol + dCol;
                    if (this.isInBounds(newRow, newCol)) {
                        const piece = board[newRow][newCol];
                        if (piece && this.getPieceColor(piece) === attackingColor &&
                            (piece === '‚ôò' || piece === '‚ôû')) {
                            return true;
                        }
                    }
                }
                
                // Pr√ºfe T√ºrme/Damen
                const rookDirections = [[-1,0], [1,0], [0,-1], [0,1]];
                for (const [dRow, dCol] of rookDirections) {
                    let newRow = kingRow + dRow;
                    let newCol = kingCol + dCol;
                    while (this.isInBounds(newRow, newCol)) {
                        const piece = board[newRow][newCol];
                        if (piece) {
                            if (this.getPieceColor(piece) === attackingColor &&
                                (piece === '‚ôñ' || piece === '‚ôú' || piece === '‚ôï' || piece === '‚ôõ')) {
                                return true;
                            }
                            break;
                        }
                        newRow += dRow;
                        newCol += dCol;
                    }
                }
                
                // Pr√ºfe L√§ufer/Damen
                const bishopDirections = [[-1,-1], [-1,1], [1,-1], [1,1]];
                for (const [dRow, dCol] of bishopDirections) {
                    let newRow = kingRow + dRow;
                    let newCol = kingCol + dCol;
                    while (this.isInBounds(newRow, newCol)) {
                        const piece = board[newRow][newCol];
                        if (piece) {
                            if (this.getPieceColor(piece) === attackingColor &&
                                (piece === '‚ôó' || piece === '‚ôù' || piece === '‚ôï' || piece === '‚ôõ')) {
                                return true;
                            }
                            break;
                        }
                        newRow += dRow;
                        newCol += dCol;
                    }
                }
                
                return false;
            }

            makeMove(fromRow, fromCol, toRow, toCol) {
                debug.log(`makeMove: (${fromRow},${fromCol}) -> (${toRow},${toCol})`, 'move');
                
                const piece = this.board[fromRow][fromCol];
                if (!piece) {
                    debug.log(`Keine Figur bei (${fromRow},${fromCol})`, 'error');
                    return { success: false, error: 'Keine Figur' };
                }
                
                if (this.getPieceColor(piece) !== this.currentPlayer) {
                    debug.log(`Falsche Farbe: ${this.getPieceColor(piece)} vs ${this.currentPlayer}`, 'error');
                    return { success: false, error: 'Nicht deine Figur' };
                }
                
                const moves = this.getValidMoves(fromRow, fromCol);
                const isValid = moves.some(m => m.row === toRow && m.col === toCol);
                
                if (!isValid) {
                    debug.log(`Ung√ºltiger Zug nach (${toRow},${toCol})`, 'error');
                    return { success: false, error: 'Ung√ºltiger Zug' };
                }
                
                const targetPiece = this.board[toRow][toCol];
                
                if (targetPiece) {
                    const capturedColor = this.getPieceColor(piece) === 'w' ? 'b' : 'w';
                    this.capturedPieces[capturedColor].push(targetPiece);
                    debug.log(`Figur geschlagen: ${targetPiece}`, 'success');
                }
                
                this.board[toRow][toCol] = piece;
                this.board[fromRow][fromCol] = '';
                debug.log(`Figur bewegt: ${piece} nach (${toRow},${toCol})`, 'success');
                
                if (this.getPieceType(piece) === 'P' && (toRow === 0 || toRow === 7)) {
                    this.board[toRow][toCol] = this.getPieceColor(piece) === 'w' ? '‚ôï' : '‚ôõ';
                    debug.log(`Bauernumwandlung zur Dame`, 'success');
                }
                
                const cols = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                const rows = ['8', '7', '6', '5', '4', '3', '2', '1'];
                let notation = '';
                
                if (this.getPieceType(piece) === 'P') {
                    if (targetPiece) notation += cols[fromCol];
                } else {
                    notation += this.getPieceType(piece);
                }
                if (targetPiece) notation += 'x';
                notation += cols[toCol] + rows[toRow];
                
                this.moveHistory.push(notation);
                debug.log(`Zugnotation: ${notation}`, 'info');
                
                this.currentPlayer = this.currentPlayer === 'w' ? 'b' : 'w';
                debug.log(`Spieler gewechselt: ${this.currentPlayer === 'w' ? 'Wei√ü' : 'Schwarz'}`, 'info');
                
                return { success: true, gameOver: false };
            }

            getState() {
                return {
                    board: this.board,
                    currentPlayer: this.currentPlayer,
                    gameOver: this.gameOver,
                    moveHistory: this.moveHistory,
                    capturedPieces: this.capturedPieces
                };
            }

            loadState(state) {
                if (!state) return;
                this.board = state.board || this.board;
                this.currentPlayer = state.currentPlayer || 'w';
                this.gameOver = state.gameOver || false;
                this.moveHistory = state.moveHistory || [];
                this.capturedPieces = state.capturedPieces || { w: [], b: [] };
                this.selectedPiece = null;
                this.validMoves = [];
            }
        }

        // =========================================
        // GAME CONTROLLER - FIXED VERSION
        // =========================================
        class GameController {
            constructor() {
                this.game = new ChessEngine();
                this.playerName = localStorage.getItem('chess_name') || '';
                this.playerId = 'p_' + Math.random().toString(36).substring(2, 10);
                this.currentRoom = null;
                this.playerColor = null;
                this.roomRef = null;
                this.isLocalMove = false;
                
                this.initUI();
                this.initFirebase();
                this.renderBoard();
                
                window.controller = this;
            }

            initUI() {
                document.getElementById('playerNameDisplay').innerText = this.playerName || 'Kein Name';
                document.getElementById('playerNameInput').value = this.playerName;
                
                document.getElementById('saveNameBtn').onclick = () => {
                    const name = document.getElementById('playerNameInput').value.trim();
                    if (name) {
                        this.playerName = name;
                        localStorage.setItem('chess_name', name);
                        document.getElementById('playerNameDisplay').innerText = name;
                        this.toast('‚úÖ Name gespeichert', 'success');
                        debug.log(`Name gesetzt: ${name}`, 'success');
                    }
                };
                
                document.getElementById('createRoomBtn').onclick = () => this.createRoom();
                document.getElementById('leaveRoomBtn').onclick = () => this.leaveRoom();
                document.getElementById('resetGameBtn').onclick = () => this.resetGame();
                
                // DEBUG BUTTONS
                document.getElementById('debugMoveE4Btn').onclick = () => {
                    if (!this.currentRoom) {
                        this.toast('‚ùå Erst Raum erstellen!', 'error');
                        return;
                    }
                    if (this.game.currentPlayer !== this.playerColor) {
                        this.toast('‚ùå Du bist nicht am Zug!', 'error');
                        return;
                    }
                    const result = this.game.makeMove(6, 4, 4, 4);
                    if (result.success) {
                        this.isLocalMove = true;
                        this.roomRef.update({
                            ...this.game.getState(),
                            lastUpdate: Date.now()
                        });
                        this.renderBoard();
                        this.toast('‚úÖ Bauer nach e4 bewegt!', 'success');
                        debug.log('DEBUG: Bauer e2->e4 erfolgreich', 'success');
                    } else {
                        this.toast(`‚ùå ${result.error}`, 'error');
                        debug.log(`DEBUG Fehler: ${result.error}`, 'error');
                    }
                };
                
                document.getElementById('debugMoveKnightBtn').onclick = () => {
                    if (!this.currentRoom) {
                        this.toast('‚ùå Erst Raum erstellen!', 'error');
                        return;
                    }
                    if (this.game.currentPlayer !== this.playerColor) {
                        this.toast('‚ùå Du bist nicht am Zug!', 'error');
                        return;
                    }
                    const result = this.game.makeMove(7, 6, 5, 5);
                    if (result.success) {
                        this.isLocalMove = true;
                        this.roomRef.update({
                            ...this.game.getState(),
                            lastUpdate: Date.now()
                        });
                        this.renderBoard();
                        this.toast('‚úÖ Springer nach f3 bewegt!', 'success');
                        debug.log('DEBUG: Springer g1->f3 erfolgreich', 'success');
                    } else {
                        this.toast(`‚ùå ${result.error}`, 'error');
                        debug.log(`DEBUG Fehler: ${result.error}`, 'error');
                    }
                };
                
                setInterval(() => {
                    const start = Date.now();
                    db.ref('.info/serverTimeOffset').once('value').then(() => {
                        const ping = Date.now() - start;
                        document.getElementById('pingValue').innerText = ping;
                    });
                }, 1000);
            }

            initFirebase() {
                const connected = db.ref('.info/connected');
                connected.on('value', (snap) => {
                    if (snap.val()) {
                        document.getElementById('statusDot').className = 'status-dot online';
                        document.getElementById('statusText').innerText = 'Verbunden';
                        this.initPresence();
                        debug.log('Firebase verbunden', 'success');
                    } else {
                        document.getElementById('statusDot').className = 'status-dot offline';
                        document.getElementById('statusText').innerText = 'Offline';
                        debug.log('Firebase Verbindung verloren', 'error');
                    }
                });
                
                db.ref('presence').on('value', (snap) => {
                    let online = 0;
                    if (snap.val()) {
                        Object.values(snap.val()).forEach(p => {
                            if (p.online && Date.now() - p.lastSeen < 120000) online++;
                        });
                    }
                    document.getElementById('onlineCount').innerText = online;
                });
                
                db.ref('rooms').on('value', (snap) => {
                    if (snap.val()) {
                        document.getElementById('roomCount').innerText = Object.keys(snap.val()).length;
                    }
                    this.updateLobby(snap.val());
                });
            }

            initPresence() {
                const presence = db.ref('presence/' + this.playerId);
                presence.set({
                    name: this.playerName,
                    online: true,
                    lastSeen: Date.now(),
                    currentRoom: this.currentRoom
                });
                presence.onDisconnect().update({
                    online: false,
                    lastSeen: Date.now()
                });
            }

            updateLobby(rooms) {
                const list = document.getElementById('lobbyList');
                if (!rooms) {
                    list.innerHTML = '<div style="color: #8e9aaf; text-align: center; padding: 20px;">Keine offenen Spiele</div>';
                    return;
                }
                
                let html = '';
                Object.entries(rooms).forEach(([id, room]) => {
                    // Pr√ºfe ob Raum beitretbar ist
                    const isJoinable = room.isPublic === true && 
                        room.players && 
                        room.players.w && 
                        (!room.players.b || room.players.b === null) &&
                        room.creatorId !== this.playerId &&
                        id !== this.currentRoom;
                    
                    if (isJoinable) {
                        const timeAgo = Math.floor((Date.now() - (room.created || Date.now())) / 60000);
                        html += `
                            <div class="lobby-item">
                                <div>
                                    <div style="color: #a0b3ff; font-size: 0.9em;">üë§ ${room.creatorName || 'Spieler'}</div>
                                    <div style="color: white;">${room.name || 'Schachspiel'}</div>
                                    <div style="color: #8e9aaf; font-size: 0.8em;">‚ö° vor ${timeAgo} min</div>
                                </div>
                                <button class="join-btn" onclick="controller.joinRoom('${id}')">Beitreten</button>
                            </div>
                        `;
                    }
                });
                
                list.innerHTML = html || '<div style="color: #8e9aaf; text-align: center; padding: 20px;">Keine offenen Spiele</div>';
            }

            // ---------------------------------
            // CREATE ROOM - FIXED
            // ---------------------------------
            async createRoom() {
                if (!this.playerName) {
                    this.toast('‚ùå Bitte erst Namen eingeben!', 'error');
                    return;
                }
                
                const roomId = 'game-' + Math.random().toString(36).substring(2, 8);
                this.currentRoom = roomId;
                this.playerColor = 'w';
                this.roomRef = db.ref('rooms/' + roomId);
                
                const roomData = {
                    isPublic: true,
                    name: `Spiel von ${this.playerName}`,
                    creatorId: this.playerId,
                    creatorName: this.playerName,
                    players: {
                        w: {
                            id: this.playerId,
                            name: this.playerName,
                            connected: true,
                            joinedAt: Date.now()
                        },
                        b: null
                    },
                    ...this.game.getState(),
                    created: Date.now(),
                    lastUpdate: Date.now()
                };
                
                await this.roomRef.set(roomData);
                db.ref('presence/' + this.playerId).update({ currentRoom: roomId });
                
                // UI sofort aktualisieren
                this.updateRoomUI();
                
                this.setupRoomListener();
                this.renderBoard();
                this.toast('üåç Spiel erstellt! Warte auf Gegner...', 'success');
                debug.log(`Raum erstellt: ${roomId}`, 'success');
            }

            // ---------------------------------
            // JOIN ROOM - FIXED
            // ---------------------------------
            async joinRoom(roomId) {
                if (!this.playerName) {
                    this.toast('‚ùå Bitte erst Namen eingeben!', 'error');
                    return;
                }
                
                debug.log(`Versuche Raum beizutreten: ${roomId}`, 'room');
                
                const roomRef = db.ref('rooms/' + roomId);
                const snap = await roomRef.get();
                
                if (!snap.exists()) {
                    this.toast('‚ùå Raum nicht gefunden!', 'error');
                    return;
                }
                
                const room = snap.val();
                
                // Pr√ºfe ob Platz frei
                if (room.players && room.players.b && room.players.b !== null) {
                    this.toast('‚ùå Dieser Raum ist bereits voll!', 'error');
                    debug.log(`Raum ${roomId} ist bereits voll`, 'error');
                    return;
                }
                
                // Raum beitreten
                this.currentRoom = roomId;
                this.playerColor = 'b';
                this.roomRef = roomRef;
                
                // Board-State laden
                this.game.loadState(room);
                
                // Spieler eintragen
                await roomRef.update({
                    'players/b': {
                        id: this.playerId,
                        name: this.playerName,
                        connected: true,
                        joinedAt: Date.now()
                    },
                    lastUpdate: Date.now()
                });
                
                // Presence updaten
                db.ref('presence/' + this.playerId).update({ currentRoom: roomId });
                
                // UI SOFORT aktualisieren
                this.updateRoomUI();
                
                // Listener einrichten
                this.setupRoomListener();
                
                // Board neu zeichnen
                this.renderBoard();
                
                this.toast('‚úÖ Raum beigetreten!', 'success');
                debug.log(`Raum beigetreten: ${roomId} als Schwarz`, 'success');
            }

            // ---------------------------------
            // UPDATE ROOM UI - NEU!
            // ---------------------------------
            updateRoomUI() {
                if (!this.currentRoom) return;
                
                // Raum-Status Card anzeigen
                document.getElementById('roomStatusCard').style.display = 'block';
                document.getElementById('roomIdDisplay').innerText = this.currentRoom;
                document.getElementById('gameRoomDisplay').innerText = this.currentRoom;
                document.getElementById('playerColorDisplay').innerText = this.playerColor === 'w' ? 'Wei√ü' : 'Schwarz';
                
                // Gegner-Status zur√ºcksetzen
                document.getElementById('opponentDisplay').innerHTML = '<span style="color: #f39c12;">‚è≥ Wartet auf Spieler...</span>';
                
                // Player Cards aktualisieren
                if (this.playerColor === 'w') {
                    document.getElementById('whiteName').innerHTML = `Wei√ü <span style="color: #2ecc71;">‚óè ${this.playerName}</span>`;
                    document.getElementById('whiteStatusBadge').className = 'connection-badge badge-online';
                    document.getElementById('whiteStatusBadge').innerHTML = '‚óè Online';
                    document.getElementById('whiteStatusText').innerText = 'Aktiv';
                    
                    document.getElementById('blackName').innerHTML = 'Schwarz';
                    document.getElementById('blackStatusBadge').className = 'connection-badge badge-waiting';
                    document.getElementById('blackStatusBadge').innerHTML = '‚è≥ Wartet';
                    document.getElementById('blackStatusText').innerText = 'Wartet auf Gegner...';
                } else {
                    document.getElementById('blackName').innerHTML = `Schwarz <span style="color: #2ecc71;">‚óè ${this.playerName}</span>`;
                    document.getElementById('blackStatusBadge').className = 'connection-badge badge-online';
                    document.getElementById('blackStatusBadge').innerHTML = '‚óè Online';
                    document.getElementById('blackStatusText').innerText = 'Aktiv';
                }
            }

            // ---------------------------------
            // SETUP ROOM LISTENER - FIXED
            // ---------------------------------
            setupRoomListener() {
                if (!this.roomRef) return;
                
                this.roomRef.on('value', (snap) => {
                    if (!snap.exists()) {
                        this.toast('üèÅ Raum wurde geschlossen', 'warning');
                        this.leaveRoom(true);
                        return;
                    }
                    
                    const data = snap.val();
                    debug.log(`Raum-Update empfangen`, 'room');
                    
                    // Board aktualisieren (nicht bei eigenem Move)
                    if (!this.isLocalMove) {
                        this.game.loadState(data);
                        this.renderBoard();
                    }
                    this.isLocalMove = false;
                    
                    // --- SPIELER-STATUS AKTUALISIEREN ---
                    if (data.players) {
                        // Wei√ü Status
                        if (data.players.w) {
                            const whiteName = data.players.w.name || 'Wei√ü';
                            document.getElementById('whiteName').innerHTML = `Wei√ü <span style="color: #2ecc71;">‚óè ${whiteName}</span>`;
                            document.getElementById('whiteStatusBadge').className = 'connection-badge badge-online';
                            document.getElementById('whiteStatusBadge').innerHTML = '‚óè Online';
                            document.getElementById('whiteStatusText').innerText = 'Aktiv';
                        }
                        
                        // Schwarz Status
                        if (data.players.b) {
                            const blackName = data.players.b.name || 'Schwarz';
                            document.getElementById('blackName').innerHTML = `Schwarz <span style="color: #2ecc71;">‚óè ${blackName}</span>`;
                            document.getElementById('blackStatusBadge').className = 'connection-badge badge-online';
                            document.getElementById('blackStatusBadge').innerHTML = '‚óè Online';
                            document.getElementById('blackStatusText').innerText = 'Aktiv';
                            
                            // Gegner-Anzeige in Raum-Card
                            if (this.playerColor === 'w') {
                                document.getElementById('opponentDisplay').innerHTML = `<span style="color: #2ecc71;">‚óè ${blackName}</span>`;
                            } else {
                                document.getElementById('opponentDisplay').innerHTML = `<span style="color: #2ecc71;">‚óè ${data.players.w.name || 'Wei√ü'}</span>`;
                            }
                        } else {
                            // Kein Schwarz - Wartezustand
                            document.getElementById('blackName').innerHTML = 'Schwarz';
                            document.getElementById('blackStatusBadge').className = 'connection-badge badge-waiting';
                            document.getElementById('blackStatusBadge').innerHTML = '‚è≥ Wartet';
                            document.getElementById('blackStatusText').innerText = 'Wartet auf Gegner...';
                            document.getElementById('opponentDisplay').innerHTML = '<span style="color: #f39c12;">‚è≥ Wartet auf Spieler...</span>';
                        }
                    }
                });
            }

            // ---------------------------------
            // LEAVE ROOM - FIXED
            // ---------------------------------
            async leaveRoom(silent = false) {
                debug.log('Verlasse Raum...', 'room');
                
                if (this.roomRef) {
                    if (this.playerColor === 'w') {
                        await this.roomRef.remove();
                        debug.log('Raum als Ersteller gel√∂scht', 'success');
                    } else {
                        await this.roomRef.update({
                            'players/b': null,
                            lastUpdate: Date.now()
                        });
                        debug.log('Als Schwarz Raum verlassen', 'success');
                    }
                    this.roomRef.off();
                }
                
                db.ref('presence/' + this.playerId).update({ currentRoom: null });
                
                this.currentRoom = null;
                this.playerColor = null;
                this.roomRef = null;
                this.game.reset();
                
                // UI zur√ºcksetzen
                document.getElementById('roomStatusCard').style.display = 'none';
                document.getElementById('gameRoomDisplay').innerText = 'Kein Raum';
                
                document.getElementById('whiteName').innerHTML = 'Wei√ü';
                document.getElementById('whiteStatusBadge').className = 'connection-badge badge-waiting';
                document.getElementById('whiteStatusBadge').innerHTML = '‚è≥ Wartet';
                document.getElementById('whiteStatusText').innerText = 'Wartet...';
                
                document.getElementById('blackName').innerHTML = 'Schwarz';
                document.getElementById('blackStatusBadge').className = 'connection-badge badge-waiting';
                document.getElementById('blackStatusBadge').innerHTML = '‚è≥ Wartet';
                document.getElementById('blackStatusText').innerText = 'Wartet...';
                
                this.renderBoard();
                
                if (!silent) {
                    this.toast('üëã Raum verlassen', 'info');
                }
                
                // Lobby aktualisieren
                setTimeout(() => {
                    db.ref('rooms').once('value').then((snap) => {
                        this.updateLobby(snap.val());
                    });
                }, 500);
            }

            async resetGame() {
                if (!this.currentRoom) {
                    this.toast('‚ùå Kein Raum verbunden!', 'error');
                    return;
                }
                if (this.playerColor !== 'w') {
                    this.toast('‚ùå Nur Wei√ü kann neustarten!', 'error');
                    return;
                }
                
                this.game.reset();
                this.isLocalMove = true;
                
                await this.roomRef.update({
                    ...this.game.getState(),
                    lastUpdate: Date.now()
                });
                
                this.toast('‚ú® Neues Spiel gestartet!', 'success');
                debug.log('Spiel zur√ºckgesetzt', 'success');
            }

            renderBoard() {
                const board = document.getElementById('chessboard');
                board.innerHTML = '';
                
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const square = document.createElement('div');
                        square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                        
                        const piece = this.game.board[r][c];
                        if (piece) square.textContent = piece;
                        
                        if (this.game.selectedPiece && 
                            this.game.selectedPiece.row === r && 
                            this.game.selectedPiece.col === c) {
                            square.classList.add('selected');
                        }
                        
                        if (this.game.validMoves.some(m => m.row === r && m.col === c)) {
                            square.classList.add('possible-move');
                        }
                        
                        square.onclick = () => this.handleSquareClick(r, c);
                        board.appendChild(square);
                    }
                }
                
                document.getElementById('moveCount').innerText = `${this.game.moveHistory.length} Z√ºge`;
                
                const movesList = document.getElementById('movesList');
                movesList.innerHTML = '';
                this.game.moveHistory.forEach((move, i) => {
                    const div = document.createElement('div');
                    div.style.cssText = 'background: #1a1e24; padding: 5px 10px; border-radius: 5px; color: #e1e9f0;';
                    if (i % 2 === 0) {
                        div.innerHTML = `<strong>${Math.floor(i / 2) + 1}.</strong> ${move}`;
                    } else {
                        div.innerText = move;
                    }
                    movesList.appendChild(div);
                });
                
                document.getElementById('whiteCard').classList.toggle('active', this.game.currentPlayer === 'w');
                document.getElementById('blackCard').classList.toggle('active', this.game.currentPlayer === 'b');
            }

            handleSquareClick(row, col) {
                debug.log(`Klick auf (${row},${col})`, 'info');
                
                if (!this.currentRoom) {
                    this.toast('üéÆ Erst Raum erstellen/beitreten!', 'warning');
                    return;
                }
                
                if (this.game.gameOver) {
                    this.toast('üèÅ Spiel beendet!', 'info');
                    return;
                }
                
                this.roomRef.once('value').then(async (snap) => {
                    const data = snap.val();
                    
                    // Pr√ºfe Gegner
                    if (!data.players || !data.players.b) {
                        this.toast('‚è≥ Warte auf Gegner...', 'warning');
                        return;
                    }
                    
                    // Pr√ºfe Zugrecht
                    if (this.game.currentPlayer !== this.playerColor) {
                        this.toast('‚è≥ Du bist nicht am Zug!', 'warning');
                        return;
                    }
                    
                    const piece = this.game.board[row][col];
                    
                    // Figur ausw√§hlen
                    if (!this.game.selectedPiece) {
                        if (piece && this.game.getPieceColor(piece) === this.playerColor) {
                            this.game.selectedPiece = { row, col };
                            this.game.validMoves = this.game.getValidMoves(row, col);
                            debug.log(`Figur ausgew√§hlt: ${piece} bei (${row},${col})`, 'success');
                            debug.log(`${this.game.validMoves.length} g√ºltige Z√ºge`, 'info');
                            this.renderBoard();
                        }
                        return;
                    }
                    
                    // Zug ausf√ºhren
                    if (this.game.selectedPiece) {
                        const fromRow = this.game.selectedPiece.row;
                        const fromCol = this.game.selectedPiece.col;
                        
                        if (row === fromRow && col === fromCol) {
                            this.game.selectedPiece = null;
                            this.game.validMoves = [];
                            debug.log('Auswahl aufgehoben', 'info');
                            this.renderBoard();
                            return;
                        }
                        
                        const isValidMove = this.game.validMoves.some(m => m.row === row && m.col === col);
                        
                        if (isValidMove) {
                            debug.log(`Versuche Zug: (${fromRow},${fromCol}) -> (${row},${col})`, 'move');
                            
                            const result = this.game.makeMove(fromRow, fromCol, row, col);
                            
                            if (result.success) {
                                this.isLocalMove = true;
                                
                                await this.roomRef.update({
                                    ...this.game.getState(),
                                    lastUpdate: Date.now()
                                });
                                
                                this.game.selectedPiece = null;
                                this.game.validMoves = [];
                                this.renderBoard();
                                debug.log('Zug erfolgreich!', 'success');
                            } else {
                                debug.log(`Zug fehlgeschlagen: ${result.error}`, 'error');
                                this.toast(`‚ùå ${result.error}`, 'error');
                                this.game.selectedPiece = null;
                                this.game.validMoves = [];
                                this.renderBoard();
                            }
                        } else {
                            debug.log('Ung√ºltiges Zielfeld', 'error');
                            this.toast('‚ùå Ung√ºltiger Zug', 'error');
                            this.game.selectedPiece = null;
                            this.game.validMoves = [];
                            this.renderBoard();
                        }
                    }
                });
            }

            toast(msg, type = 'info') {
                debug.log(`Toast: ${msg}`, type);
                const toast = document.getElementById('toast');
                toast.innerText = msg;
                toast.className = 'toast ' + type;
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 3000);
            }
        }

        // Controller starten
        const controller = new GameController();
    </script>
</body>
</html>
